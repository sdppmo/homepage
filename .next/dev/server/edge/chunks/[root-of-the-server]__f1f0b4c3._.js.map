{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/lib/config.ts"],"sourcesContent":["/**\n * Application configuration\n * These values are safe to expose in the frontend\n */\n\nexport const config = {\n  supabase: {\n    url: 'https://iwudkwhafyrhgzuntdgm.supabase.co',\n    anonKey: 'sb_publishable_6GvHywiSQrcVXGapyPwvBA_lh2A76OW',\n  },\n  \n  protectedPaths: [\n    '/pages/k-col web software/',\n    '/pages/K-product/2H_steel_product.html',\n    '/pages/admin.html',\n  ],\n} as const;\n\nexport type Config = typeof config;\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;AAEM,MAAM,SAAS;IACpB,UAAU;QACR,KAAK;QACL,SAAS;IACX;IAEA,gBAAgB;QACd;QACA;QACA;KACD;AACH"}},
    {"offset": {"line": 38, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/lib/supabase/middleware.ts"],"sourcesContent":["/**\n * Supabase client for middleware usage\n * Uses @supabase/ssr for proper cookie handling in middleware\n */\n\nimport { createServerClient } from '@supabase/ssr';\nimport { NextResponse, type NextRequest } from 'next/server';\nimport { config } from '../config';\n\nexport async function updateSession(request: NextRequest) {\n  let supabaseResponse = NextResponse.next({\n    request,\n  });\n\n  const supabase = createServerClient(\n    config.supabase.url,\n    config.supabase.anonKey,\n    {\n      cookies: {\n        getAll() {\n          return request.cookies.getAll();\n        },\n        setAll(cookiesToSet) {\n          cookiesToSet.forEach(({ name, value, options }) => {\n            request.cookies.set(name, value);\n            supabaseResponse.cookies.set(name, value, options);\n          });\n        },\n      },\n    }\n  );\n\n  // IMPORTANT: Avoid writing any logic between createServerClient and\n  // supabase.auth.getUser(). A simple mistake could make it very hard to debug\n  // issues with users being randomly logged out.\n\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  // Return user and response for middleware to handle\n  return { user, response: supabaseResponse };\n}\n"],"names":[],"mappings":";;;;AAAA;;;CAGC,GAED;AAAA;AACA;AAAA;AACA;;;;AAEO,eAAe,cAAc,OAAoB;IACtD,IAAI,mBAAmB,gMAAY,CAAC,IAAI,CAAC;QACvC;IACF;IAEA,MAAM,WAAW,IAAA,uMAAkB,EACjC,sIAAM,CAAC,QAAQ,CAAC,GAAG,EACnB,sIAAM,CAAC,QAAQ,CAAC,OAAO,EACvB;QACE,SAAS;YACP;gBACE,OAAO,QAAQ,OAAO,CAAC,MAAM;YAC/B;YACA,QAAO,YAAY;gBACjB,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE;oBAC5C,QAAQ,OAAO,CAAC,GAAG,CAAC,MAAM;oBAC1B,iBAAiB,OAAO,CAAC,GAAG,CAAC,MAAM,OAAO;gBAC5C;YACF;QACF;IACF;IAGF,oEAAoE;IACpE,6EAA6E;IAC7E,+CAA+C;IAE/C,MAAM,EACJ,MAAM,EAAE,IAAI,EAAE,EACf,GAAG,MAAM,SAAS,IAAI,CAAC,OAAO;IAE/B,oDAAoD;IACpD,OAAO;QAAE;QAAM,UAAU;IAAiB;AAC5C"}},
    {"offset": {"line": 84, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/lib/rate-limit.ts"],"sourcesContent":["/**\n * In-memory rate limiter\n * Limits requests per IP address\n */\n\ninterface RateLimitEntry {\n  count: number;\n  resetAt: number;\n}\n\nconst store = new Map<string, RateLimitEntry>();\n\n// Cleanup old entries every 5 minutes\nsetInterval(() => {\n  const now = Date.now();\n  for (const [ip, entry] of store.entries()) {\n    if (entry.resetAt < now) {\n      store.delete(ip);\n    }\n  }\n}, 5 * 60 * 1000);\n\n/**\n * Check if IP is within rate limit\n * @param ip - IP address to check\n * @param limit - Maximum requests per second (default: 10)\n * @returns true if within limit, false if exceeded\n */\nexport function rateLimit(ip: string, limit: number = 10): boolean {\n  const now = Date.now();\n  const windowMs = 1000; // 1 second window\n  \n  const entry = store.get(ip);\n  \n  if (!entry || entry.resetAt < now) {\n    // New window\n    store.set(ip, {\n      count: 1,\n      resetAt: now + windowMs,\n    });\n    return true;\n  }\n  \n  if (entry.count >= limit) {\n    // Rate limit exceeded\n    return false;\n  }\n  \n  // Increment count\n  entry.count++;\n  return true;\n}\n\n/**\n * Get current rate limit status for an IP\n * @param ip - IP address to check\n * @returns Current count and reset time, or null if no entry\n */\nexport function getRateLimitStatus(ip: string): { count: number; resetAt: number } | null {\n  return store.get(ip) || null;\n}\n\n/**\n * Clear rate limit for an IP (useful for testing)\n * @param ip - IP address to clear\n */\nexport function clearRateLimit(ip: string): void {\n  store.delete(ip);\n}\n\n/**\n * Clear all rate limits (useful for testing)\n */\nexport function clearAllRateLimits(): void {\n  store.clear();\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;AAOD,MAAM,QAAQ,IAAI;AAElB,sCAAsC;AACtC,YAAY;IACV,MAAM,MAAM,KAAK,GAAG;IACpB,KAAK,MAAM,CAAC,IAAI,MAAM,IAAI,MAAM,OAAO,GAAI;QACzC,IAAI,MAAM,OAAO,GAAG,KAAK;YACvB,MAAM,MAAM,CAAC;QACf;IACF;AACF,GAAG,IAAI,KAAK;AAQL,SAAS,UAAU,EAAU,EAAE,QAAgB,EAAE;IACtD,MAAM,MAAM,KAAK,GAAG;IACpB,MAAM,WAAW,MAAM,kBAAkB;IAEzC,MAAM,QAAQ,MAAM,GAAG,CAAC;IAExB,IAAI,CAAC,SAAS,MAAM,OAAO,GAAG,KAAK;QACjC,aAAa;QACb,MAAM,GAAG,CAAC,IAAI;YACZ,OAAO;YACP,SAAS,MAAM;QACjB;QACA,OAAO;IACT;IAEA,IAAI,MAAM,KAAK,IAAI,OAAO;QACxB,sBAAsB;QACtB,OAAO;IACT;IAEA,kBAAkB;IAClB,MAAM,KAAK;IACX,OAAO;AACT;AAOO,SAAS,mBAAmB,EAAU;IAC3C,OAAO,MAAM,GAAG,CAAC,OAAO;AAC1B;AAMO,SAAS,eAAe,EAAU;IACvC,MAAM,MAAM,CAAC;AACf;AAKO,SAAS;IACd,MAAM,KAAK;AACb"}},
    {"offset": {"line": 140, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/src/middleware.ts"],"sourcesContent":["import { type NextRequest, NextResponse } from 'next/server';\nimport { updateSession } from './lib/supabase/middleware';\nimport { rateLimit } from './lib/rate-limit';\n\nconst PROTECTED_PATTERNS = [\n  '/k-col/auto-find-section',\n  '/k-col/calculator',\n  '/k-col/boq-report',\n  '/k-col/user-guide',\n  '/k-col/developer-guide',\n  '/k-col/print',\n  '/k-col/calc-data-1',\n  '/k-col/calc-data-2',\n  '/admin',\n];\n\nconst BLOCKED_PATTERNS = [\n  /^\\/\\.git/,\n  /^\\/\\.env/,\n  /\\/wp-admin/,\n  /\\/wp-login/,\n  /\\.php$/,\n];\n\nexport async function middleware(request: NextRequest) {\n  const pathname = request.nextUrl.pathname;\n\n  for (const pattern of BLOCKED_PATTERNS) {\n    if (pattern.test(pathname)) {\n      return new NextResponse(null, { status: 404 });\n    }\n  }\n\n  const ip = request.headers.get('x-forwarded-for') || \n              request.headers.get('x-real-ip') || \n              'unknown';\n  if (!rateLimit(ip, 10)) {\n    return new NextResponse('Too Many Requests', { status: 429 });\n  }\n\n  const { user, response } = await updateSession(request);\n\n  const isProtectedRoute = PROTECTED_PATTERNS.some(pattern => \n    pathname.startsWith(pattern)\n  );\n\n  if (isProtectedRoute && !user) {\n    const redirectUrl = new URL('/login', request.url);\n    redirectUrl.searchParams.set('redirect', pathname);\n    return NextResponse.redirect(redirectUrl);\n  }\n\n  return response;\n}\n\nexport const config = {\n  matcher: [\n    '/((?!_next/static|_next/image|favicon.ico|.*\\\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',\n  ],\n};\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AACA;AACA;;;;AAEA,MAAM,qBAAqB;IACzB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED,MAAM,mBAAmB;IACvB;IACA;IACA;IACA;IACA;CACD;AAEM,eAAe,WAAW,OAAoB;IACnD,MAAM,WAAW,QAAQ,OAAO,CAAC,QAAQ;IAEzC,KAAK,MAAM,WAAW,iBAAkB;QACtC,IAAI,QAAQ,IAAI,CAAC,WAAW;YAC1B,OAAO,IAAI,gMAAY,CAAC,MAAM;gBAAE,QAAQ;YAAI;QAC9C;IACF;IAEA,MAAM,KAAK,QAAQ,OAAO,CAAC,GAAG,CAAC,sBACnB,QAAQ,OAAO,CAAC,GAAG,CAAC,gBACpB;IACZ,IAAI,CAAC,IAAA,gJAAS,EAAC,IAAI,KAAK;QACtB,OAAO,IAAI,gMAAY,CAAC,qBAAqB;YAAE,QAAQ;QAAI;IAC7D;IAEA,MAAM,EAAE,IAAI,EAAE,QAAQ,EAAE,GAAG,MAAM,IAAA,6JAAa,EAAC;IAE/C,MAAM,mBAAmB,mBAAmB,IAAI,CAAC,CAAA,UAC/C,SAAS,UAAU,CAAC;IAGtB,IAAI,oBAAoB,CAAC,MAAM;QAC7B,MAAM,cAAc,IAAI,IAAI,UAAU,QAAQ,GAAG;QACjD,YAAY,YAAY,CAAC,GAAG,CAAC,YAAY;QACzC,OAAO,gMAAY,CAAC,QAAQ,CAAC;IAC/B;IAEA,OAAO;AACT;AAEO,MAAM,SAAS;IACpB,SAAS;QACP;KACD;AACH"}}]
}