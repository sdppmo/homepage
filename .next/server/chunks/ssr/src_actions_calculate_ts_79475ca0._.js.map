{"version":3,"sources":["../../../../src/lib/calculations/cross-h-column.ts","../../../../src/lib/calculations/steel-section.ts","../../../../src/lib/calculations/boq.ts","../../../../src/actions/calculate.ts"],"sourcesContent":["'use server';\n\nexport type WebClass = 'Compact' | 'Noncompact' | 'Slender';\n\nexport interface CrossHSectionDimensionsInput {\n  h1: number;\n  h2: number;\n  b1: number;\n  b2: number;\n}\n\nexport interface CrossHThicknessInput {\n  tw: number;\n  tf: number;\n}\n\nexport interface MaterialInput {\n  Fy: number;\n  E: number;\n  nu: number;\n}\n\nexport interface EffectiveLengthFactorsInput {\n  Kx: number;\n  Ky: number;\n  Kz: number;\n}\n\nexport interface MemberLengthsInput {\n  /** mm */\n  Lx: number;\n  /** mm */\n  Ly: number;\n}\n\nexport interface PMMLoadInput {\n  Pu: number;\n  Mux: number;\n  Muy: number;\n}\n\nexport interface CrossHSectionCalcInput {\n  thickness: CrossHThicknessInput;\n  material: MaterialInput;\n  factors: EffectiveLengthFactorsInput;\n  lengths: MemberLengthsInput;\n  loads: PMMLoadInput;\n  dims: CrossHSectionDimensionsInput;\n}\n\nexport interface CrossHSectionCalcResult {\n  phi_Pn: number;\n  area: number;\n  ratio_pmm: number;\n  tw: number;\n  tf: number;\n  lcf: number;\n  lcfr: number;\n  isSlenderFlange: boolean;\n  isCompressiveNG: boolean;\n\n  // web slenderness (flexure)\n  lw1: number;\n  lw2: number;\n  lwp: number;\n  lwr: number;\n  web1Class: WebClass;\n  web2Class: WebClass;\n  isSlenderWeb: boolean;\n\n  lfp: number;\n  lfr: number;\n  lf1: number;\n  lf2: number;\n  flange1Class: WebClass;\n  flange2Class: WebClass;\n\n  phi_Mnx: number;\n  phi_Mny: number;\n\n  phi_Vnx: number;\n  phi_Vny: number;\n}\n\nexport interface SectionCombination {\n  H1: number;\n  H2: number;\n  B1: number;\n  B2: number;\n  name: string;\n}\n\nexport interface CalculateSectionArgs {\n  tw: number;\n  tf: number;\n  Fy: number;\n  E: number;\n  nu: number;\n  Kx: number;\n  Ky: number;\n  Kz: number;\n  Lx: number;\n  Ly: number;\n  Pu: number;\n  Mux: number;\n  Muy: number;\n  h1: number;\n  h2: number;\n  b1: number;\n  b2: number;\n}\n\n/**\n * Ported EXACTLY from `protected-source/auto-find-section.html`.\n *\n * This file is server-only by design.\n */\n\n// 조합 3: Rolled H 단면의 표준 tw, tf, r 값 (KS 표준)\nconst rolledHStandardThickness: Record<number, { tw: number; tf: number; r: number }> = {\n  400: { tw: 8, tf: 13, r: 16 },\n  450: { tw: 9, tf: 14, r: 18 },\n  500: { tw: 10, tf: 16, r: 20 },\n  506: { tw: 11, tf: 19, r: 20 },\n  482: { tw: 12, tf: 17, r: 28 },\n  488: { tw: 12, tf: 20, r: 28 },\n  582: { tw: 12, tf: 17, r: 28 },\n  588: { tw: 12, tf: 20, r: 28 },\n  600: { tw: 11, tf: 17, r: 22 },\n};\n\n// 세 가지 조합 정의\nconst combinations: SectionCombination[] = [\n  { H1: 500, H2: 500, B1: 300, B2: 300, name: 'BH500×B300' },\n  { H1: 450, H2: 450, B1: 250, B2: 250, name: 'BH450×B250' },\n  // 조합 3: Rolled H 단면들\n  { H1: 400, H2: 400, B1: 200, B2: 200, name: 'H400×B200' },\n  { H1: 450, H2: 450, B1: 200, B2: 200, name: 'H450×B200' },\n  { H1: 500, H2: 500, B1: 200, B2: 200, name: 'H500×B200' },\n  { H1: 506, H2: 506, B1: 201, B2: 201, name: 'H506×B201' },\n  { H1: 482, H2: 482, B1: 300, B2: 300, name: 'H482×B300' },\n  { H1: 488, H2: 488, B1: 300, B2: 300, name: 'H488×B300' },\n  { H1: 582, H2: 582, B1: 300, B2: 300, name: 'H582×B300' },\n  { H1: 588, H2: 588, B1: 300, B2: 300, name: 'H588×B300' },\n  { H1: 600, H2: 600, B1: 200, B2: 200, name: 'H600×B200' },\n];\n\nexport async function getCombinations(): Promise<SectionCombination[]> {\n  return combinations;\n}\n\nexport async function getRolledHStandardThickness(): Promise<\n  Record<number, { tw: number; tf: number; r: number }>\n> {\n  return rolledHStandardThickness;\n}\n\nfunction hasOwn(obj: object, key: string | number): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nfunction isCombination3(h1: number, b1: number): boolean {\n  const hasStandardH = hasOwn(rolledHStandardThickness, h1);\n  return (\n    hasStandardH &&\n    (b1 === 200 ||\n      b1 === 201 ||\n      (b1 === 300 && (h1 === 482 || h1 === 488 || h1 === 582 || h1 === 588)))\n  );\n}\n\n/**\n * Port of `calculateSection()` from `protected-source/auto-find-section.html`.\n *\n * IMPORTANT:\n * - Keep formulas, constants, and control-flow identical.\n * - Units are assumed to already be normalized by the caller.\n */\nexport async function calculateSection(input: CrossHSectionCalcInput): Promise<CrossHSectionCalcResult> {\n  const {\n    thickness: { tw, tf },\n    material: { Fy, E, nu },\n    factors: { Kx, Ky, Kz },\n    lengths: { Lx, Ly },\n    loads: { Pu, Mux, Muy },\n    dims: { h1, h2, b1, b2 },\n  } = input;\n\n  return calculateSectionByArgs({\n    tw,\n    tf,\n    Fy,\n    E,\n    nu,\n    Kx,\n    Ky,\n    Kz,\n    Lx,\n    Ly,\n    Pu,\n    Mux,\n    Muy,\n    h1,\n    h2,\n    b1,\n    b2,\n  });\n}\n\n/**\n * Original positional version for parity with HTML.\n */\nexport async function calculateSectionByInputs(\n  tw: number,\n  tf: number,\n  Fy: number,\n  E: number,\n  nu: number,\n  Kx: number,\n  Ky: number,\n  Kz: number,\n  Lx: number,\n  Ly: number,\n  Pu: number,\n  Mux: number,\n  Muy: number,\n  h1: number,\n  h2: number,\n  b1: number,\n  b2: number\n): Promise<CrossHSectionCalcResult> {\n  return calculateSectionByArgs({\n    tw,\n    tf,\n    Fy,\n    E,\n    nu,\n    Kx,\n    Ky,\n    Kz,\n    Lx,\n    Ly,\n    Pu,\n    Mux,\n    Muy,\n    h1,\n    h2,\n    b1,\n    b2,\n  });\n}\n\nfunction calculateSectionByArgs(args: CalculateSectionArgs): CrossHSectionCalcResult {\n  const { tw, tf, Fy, E, nu, Kx, Ky, Kz, Lx, Ly, Pu, Mux, Muy, h1, h2, b1, b2 } = args;\n\n  // ===== 입력값 가져오기 (Main Calculator quickCalculate와 동일) =====\n  const tw1 = tw;\n  const tf1 = tf;\n  const tw2 = tw;\n  const tf2 = tf;\n\n  // 조합 3 (Rolled H)인지 확인하여 r1, r2 값 결정\n  const comb3 = isCombination3(h1, b1);\n  let r1: number;\n  let r2: number;\n  if (comb3) {\n    const standardThickness = rolledHStandardThickness[h1];\n    r1 = standardThickness.r || 0;\n    r2 = standardThickness.r || 0;\n  } else {\n    r1 = 0;\n    r2 = 0;\n  }\n\n  // ===== HBeam Class calculations (계산서와 완전히 동일한 공식 사용) =====\n  const hw3 = h1 - 2 * tf1;\n  const hw6 = h2 - 2 * tf2;\n  const d1 = h1 / 2 - tf1 / 2;\n  const d4 = h2 / 2 - tf2 / 2;\n\n  // Total section area - Cross H section\n  const ag1 = b1 * tf1;\n  const ag2 = b1 * tf1;\n  const ag3 = hw3 * tw1;\n  const ag4 = b2 * tf2;\n  const ag5 = b2 * tf2;\n  const ag6 = hw6 * tw2;\n  const ag7 = 4 * (r1 * r1 - (Math.PI * r1 * r1) / 4);\n  const ag8 = 4 * (r2 * r2 - (Math.PI * r2 * r2) / 4);\n  const ag9 = tw1 * tw2;\n  const area = ag1 + ag2 + ag3 + ag4 + ag5 + ag6 + ag7 + ag8 - ag9;\n\n  // Second inertia moment X-axis\n  const Ix1 = (1 / 12) * b1 * Math.pow(tf1, 3) + ag1 * Math.pow(d1, 2);\n  const Ix2 = (1 / 12) * b1 * Math.pow(tf1, 3) + ag1 * Math.pow(d1, 2);\n  const Ix3 = (1 / 12) * tw1 * Math.pow(hw3, 3);\n  const Ix4 = (1 / 12) * tf2 * Math.pow(b2, 3);\n  const Ix5 = (1 / 12) * tf2 * Math.pow(b2, 3);\n  const Ix6 = (1 / 12) * hw6 * Math.pow(tw2, 3);\n  const Ix = Ix1 + Ix2 + Ix3 + Ix4 + Ix5 + Ix6;\n\n  // Second inertia moment Y-axis\n  const Iy4 = (1 / 12) * b2 * Math.pow(tf2, 3) + ag4 * Math.pow(d4, 2);\n  const Iy5 = (1 / 12) * b2 * Math.pow(tf2, 3) + ag4 * Math.pow(d4, 2);\n  const Iy6 = (1 / 12) * tw2 * Math.pow(hw6, 3);\n  const Iy1 = (1 / 12) * tf1 * Math.pow(b1, 3);\n  const Iy2 = (1 / 12) * tf1 * Math.pow(b1, 3);\n  const Iy3 = (1 / 12) * hw3 * Math.pow(tw2, 3);\n  const Iy = Iy1 + Iy2 + Iy3 + Iy4 + Iy5 + Iy6;\n\n  // Radius of gyration\n  const ix = Math.sqrt(Ix / area);\n  const iy = Math.sqrt(Iy / area);\n\n  // Elastic section modulus\n  const sx = Ix / (h1 / 2);\n  const sy = Iy / (h2 / 2);\n\n  // Plastic section modulus Zx\n  const Zx1 = b1 * tf1 * d1;\n  const Zx2 = b1 * tf1 * d1;\n  const Zx3 = ((tw1 * hw3) / 2) * (hw3 / 4);\n  const Zx4 = ((tw1 * hw3) / 2) * (hw3 / 4);\n  const Zx5 = (b2 * b2 * tf2) / 2;\n  const Zx6 = ((tw2 * hw6) / 8) * 2;\n  const zx = Zx1 + Zx2 + Zx3 + Zx4 + Zx5 + Zx6;\n\n  // Plastic section modulus Zy\n  const Zy1 = b2 * tf2 * d4;\n  const Zy2 = b2 * tf2 * d4;\n  const Zy3 = ((tw2 * hw6) / 2) * (hw6 / 4);\n  const Zy4 = ((tw2 * hw6) / 2) * (hw6 / 4);\n  const Zy5 = (b1 * b1 * tf1) / 2;\n  const Zy6 = ((tw1 * hw3) / 8) * 2;\n  const zy = Zy1 + Zy2 + Zy3 + Zy4 + Zy5 + Zy6;\n\n  // Torsional constant J\n  const J1 = (2 * b1 * Math.pow(tf1, 3) + h1 * Math.pow(tw1, 3)) / 3;\n  const J2 = (2 * b2 * Math.pow(tf2, 3) + h2 * Math.pow(tw2, 3)) / 3;\n  const J = J1 + J2;\n\n  // Warping constant Cw\n  const cw = (Iy * Math.pow(h1 - tf1, 2)) / 4;\n\n  // ===== Column Class calculations =====\n  const lcfr = 0.56 * Math.sqrt(E / Fy);\n  const lcf = b2 / (2 * tf2);\n  const isSlenderFlange = lcf > lcfr;\n\n  // Web slenderness ratio for Flexure\n  const lwp = 3.76 * Math.sqrt(E / Fy);\n  const lwr = 5.7 * Math.sqrt(E / Fy);\n  const lw1 = (h1 - 2 * (tf1 + r1) - tw1) / (2 * tw1);\n  const lw2 = (h2 - 2 * (tf2 + r2) - tw2) / (2 * tw2);\n\n  const lfp = 0.38 * Math.sqrt(E / Fy);\n  const lfr = 1.0 * Math.sqrt(E / Fy);\n  const lf1 = b1 / (2 * tf1);\n  const lf2 = b2 / (2 * tf2);\n\n  // Web classification: Compact / Noncompact / Slender\n  let web1Class: WebClass = 'Compact';\n  let web2Class: WebClass = 'Compact';\n  let isSlenderWeb = false;\n\n  if (lw1 <= lwp) {\n    web1Class = 'Compact';\n  } else if (lw1 <= lwr) {\n    web1Class = 'Noncompact';\n  } else {\n    web1Class = 'Slender';\n    isSlenderWeb = true;\n  }\n\n  if (lw2 <= lwp) {\n    web2Class = 'Compact';\n  } else if (lw2 <= lwr) {\n    web2Class = 'Noncompact';\n  } else {\n    web2Class = 'Slender';\n    isSlenderWeb = true;\n  }\n\n  let flange1Class: WebClass = 'Compact';\n  let flange2Class: WebClass = 'Compact';\n\n  if (lf1 <= lfp) {\n    flange1Class = 'Compact';\n  } else if (lf1 <= lfr) {\n    flange1Class = 'Noncompact';\n  } else {\n    flange1Class = 'Slender';\n  }\n\n  if (lf2 <= lfp) {\n    flange2Class = 'Compact';\n  } else if (lf2 <= lfr) {\n    flange2Class = 'Noncompact';\n  } else {\n    flange2Class = 'Slender';\n  }\n\n  // Slenderness ratio\n  const lambdaX = (Kx * Lx) / ix;\n  const lambdaY = (Ky * Ly) / iy;\n  const lambda = Math.max(lambdaX, lambdaY);\n\n  // Flexural Buckling Stress Fe1\n  const Fe1 = Math.pow(Math.PI, 2) * E / Math.pow(lambda, 2);\n\n  // Torsional Buckling Stress Fe2\n  const G = E / (2 * (1 + nu));\n  const Fe2 = (Math.pow(Math.PI, 2) * E * cw / Math.pow(Kz * Lx, 2) + G * J) / (Ix + Iy);\n\n  // Critical stress Fcr\n  const Fe = Math.min(Fe1, Fe2);\n  const Fcr = Math.pow(0.658, Fy / Fe) * Fy;\n\n  // Compressive Strength phi_Pn\n  const phi_c = 0.9;\n  const phi_Pn = (phi_c * area * Fcr) / 1000;\n\n  // Flexural Strength\n  const Mpx = Math.min(Fy * zx, 1.6 * Fy * sx) / 1_000_000;\n  const Mpy = Math.min(Fy * zy, 1.6 * Fy * sy) / 1_000_000;\n  const phi_b = 0.9;\n  const phi_Mnx = phi_b * Mpx;\n  const phi_Mny = phi_b * Mpy;\n\n  const As1 = hw3 * tw1 + 2 * tf1 * b1;\n  const As2 = hw6 * tw2 + 2 * tf2 * b2;\n  const Vny = (0.6 * Fy * As1) / 1000;\n  const Vnx = (0.6 * Fy * As2) / 1000;\n  const phi_Vny = Vny;\n  const phi_Vnx = Vnx;\n\n  // ===== 비율 계산 =====\n  const ratio_comp = Pu / phi_Pn;\n  const ratio_bendX = phi_Mnx > 0 ? Mux / phi_Mnx : 0;\n  const ratio_bendY = phi_Mny > 0 ? Muy / phi_Mny : 0;\n  const ratio_pmm =\n    ratio_comp >= 0.2\n      ? ratio_comp + (8 / 9) * (ratio_bendX + ratio_bendY)\n      : ratio_comp / 2 + ratio_bendX + ratio_bendY;\n\n  const isCompressiveNG = phi_Pn < Pu;\n\n  return {\n    phi_Pn,\n    area,\n    ratio_pmm,\n    tw,\n    tf,\n    lcf,\n    lcfr,\n    isSlenderFlange,\n    isCompressiveNG,\n    lw1,\n    lw2,\n    lwp,\n    lwr,\n    web1Class,\n    web2Class,\n    isSlenderWeb,\n    lfp,\n    lfr,\n    lf1,\n    lf2,\n    flange1Class,\n    flange2Class,\n    phi_Mnx,\n    phi_Mny,\n    phi_Vnx,\n    phi_Vny,\n  };\n}\n","'use server';\n\nexport interface MaterialInput {\n  Fy: number;\n  E: number;\n  nu: number;\n}\n\nexport interface EffectiveLengthFactorsInput {\n  Kx: number;\n  Ky: number;\n  Kz: number;\n}\n\nexport interface MemberLengthsInput {\n  /** mm */\n  Lx: number;\n  /** mm */\n  Ly: number;\n}\n\nexport interface PMMLoadInput {\n  Pu: number;\n  Mux: number;\n  Muy: number;\n}\n\nexport interface CrossHSectionDimensionsInput {\n  h1: number;\n  h2: number;\n  b1: number;\n  b2: number;\n}\n\nexport interface OptimalSectionSearchInput {\n  loads: PMMLoadInput;\n  material: MaterialInput;\n  factors: EffectiveLengthFactorsInput;\n  lengths: MemberLengthsInput;\n  dims: CrossHSectionDimensionsInput;\n  /** default 1.0 */\n  pmmLimit?: number;\n  twMin: number;\n  twMax: number;\n  tfMin: number;\n  tfMax: number;\n}\n\nexport interface OptimalSectionSearchResult {\n  tw: number | null;\n  tf: number | null;\n  area: number;\n  ratioPMM: number;\n  isSlenderFlange: boolean;\n}\n\nimport {\n  calculateSectionByInputs,\n  getCombinations as getCombos,\n  getRolledHStandardThickness,\n} from './cross-h-column';\n\n/**\n * Ported EXACTLY from `protected-source/auto-find-section.html`.\n *\n * This file is server-only by design.\n */\n\nexport async function getCombinations() {\n  return getCombos();\n}\n\n// getTwRange()/getTfRange() in HTML read from DOM inputs.\n// In server-side version, the caller must pass explicit min/max.\nexport async function getTwRange(twMin: number, twMax: number): Promise<number[]> {\n  const range: number[] = [];\n  for (let i = twMin; i <= twMax; i++) {\n    range.push(i);\n  }\n  return range;\n}\n\nexport async function getTfRange(tfMin: number, tfMax: number): Promise<number[]> {\n  const range: number[] = [];\n  for (let i = tfMin; i <= tfMax; i++) {\n    range.push(i);\n  }\n  return range;\n}\n\nfunction hasOwn(obj: object, key: string | number): boolean {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nfunction isCombination3(h1: number, b1: number): boolean {\n  const thickness = rolledHStandardThicknessCache;\n  const hasStandardH = hasOwn(thickness, h1);\n  return (\n    hasStandardH &&\n    (b1 === 200 ||\n      b1 === 201 ||\n      (b1 === 300 && (h1 === 482 || h1 === 488 || h1 === 582 || h1 === 588)))\n  );\n}\n\nlet rolledHStandardThicknessCache: Record<number, { tw: number; tf: number; r: number }> = {};\nasync function getRolledThicknessCache() {\n  if (Object.keys(rolledHStandardThicknessCache).length === 0) {\n    rolledHStandardThicknessCache = await getRolledHStandardThickness();\n  }\n  return rolledHStandardThicknessCache;\n}\n\n/**\n * Port of `findOptimalSection()` from `protected-source/auto-find-section.html`.\n */\nexport async function findOptimalSection(input: OptimalSectionSearchInput): Promise<OptimalSectionSearchResult> {\n  const { loads, material, factors, lengths, dims } = input;\n  const { Pu, Mux, Muy } = loads;\n  const { Fy, E, nu } = material;\n  const { Kx, Ky, Kz } = factors;\n  const { Lx, Ly } = lengths;\n  const { h1, h2, b1, b2 } = dims;\n\n  let bestTw: number | null = null;\n  let bestTf: number | null = null;\n  let bestArea = Infinity;\n  let bestPMM = 0;\n  let bestDiff = Infinity;\n  let bestIsSlenderFlange = false;\n\n  const pmmLimit = input.pmmLimit ?? 1.0;\n\n  const rolledHStandardThickness = await getRolledThicknessCache();\n  const comb3 = isCombination3(h1, b1);\n\n  let twRange: number[];\n  let tfRange: number[];\n\n  if (comb3) {\n    const standardThickness = rolledHStandardThickness[h1];\n    const standardTw = standardThickness.tw;\n    const standardTf = standardThickness.tf;\n    twRange = [standardTw];\n    tfRange = [standardTf];\n  } else {\n    twRange = [];\n    tfRange = [];\n    for (let i = input.twMin; i <= input.twMax; i++) twRange.push(i);\n    for (let i = input.tfMin; i <= input.tfMax; i++) tfRange.push(i);\n  }\n\n  for (const tw of twRange) {\n    for (const tf of tfRange) {\n      if (tf < tw) continue;\n\n      const result = await calculateSectionByInputs(\n        tw,\n        tf,\n        Fy,\n        E,\n        nu,\n        Kx,\n        Ky,\n        Kz,\n        Lx,\n        Ly,\n        Pu,\n        Mux,\n        Muy,\n        h1,\n        h2,\n        b1,\n        b2\n      );\n\n      if (result.isSlenderFlange) continue;\n      if (result.isSlenderWeb) continue;\n\n      if (result.ratio_pmm > 0 && result.ratio_pmm <= pmmLimit) {\n        if (result.area < bestArea) {\n          bestArea = result.area;\n          bestTw = tw;\n          bestTf = tf;\n          bestPMM = result.ratio_pmm;\n          bestDiff = Math.abs(pmmLimit - result.ratio_pmm);\n          bestIsSlenderFlange = result.isSlenderFlange;\n        }\n      }\n    }\n  }\n\n  if (bestTw === null) {\n    let minPMM = Infinity;\n    const twRange2 = comb3\n      ? twRange\n      : (() => {\n          const r: number[] = [];\n          for (let i = input.twMin; i <= input.twMax; i++) r.push(i);\n          return r;\n        })();\n    const tfRange2 = comb3\n      ? tfRange\n      : (() => {\n          const r: number[] = [];\n          for (let i = input.tfMin; i <= input.tfMax; i++) r.push(i);\n          return r;\n        })();\n\n    for (const tw of twRange2) {\n      for (const tf of tfRange2) {\n        if (tf < tw) continue;\n\n        const result = await calculateSectionByInputs(\n          tw,\n          tf,\n          Fy,\n          E,\n          nu,\n          Kx,\n          Ky,\n          Kz,\n          Lx,\n          Ly,\n          Pu,\n          Mux,\n          Muy,\n          h1,\n          h2,\n          b1,\n          b2\n        );\n\n        if (result.isSlenderFlange) continue;\n        if (result.isSlenderWeb) continue;\n        if (result.isCompressiveNG) continue;\n\n        if (result.ratio_pmm < minPMM) {\n          minPMM = result.ratio_pmm;\n          bestArea = result.area;\n          bestTw = tw;\n          bestTf = tf;\n          bestPMM = result.ratio_pmm;\n          bestIsSlenderFlange = result.isSlenderFlange;\n        }\n      }\n    }\n  }\n\n  void bestDiff;\n\n  return {\n    tw: bestTw,\n    tf: bestTf,\n    area: bestArea,\n    ratioPMM: bestPMM,\n    isSlenderFlange: bestIsSlenderFlange,\n  };\n}\n","'use server';\n\nexport interface BOQColumnItem {\n  names: string[];\n  combination: string;\n  h: number;\n  b: number;\n  tw: number;\n  tf: number;\n  area: number;\n  unitWeight: number;\n  /** length for one column (m) */\n  length: number;\n  count: number;\n  steelGrade: string;\n\n  H1?: number;\n  H2?: number;\n  B1?: number;\n  B2?: number;\n\n  quantity?: number;\n  isGrouped?: boolean;\n  originalNames?: string[];\n  originalCount?: number;\n}\n\nexport interface BOQPlateAggregatedItem {\n  thickness_mm: number;\n  avgWidth: number;\n  unitWeight: number;\n  totalLength: number;\n  totalCount: number;\n  totalWeight: number;\n  usageParts: string;\n  steelGrade: string;\n  mergeInfo?: string;\n  thickness?: number;\n}\n\nexport interface BOQRolledHGroup {\n  combination: string;\n  length: number;\n  count: number;\n  unitWeight: number;\n  totalWeight: number;\n  names: string[];\n  steelGrade: string;\n  isGrouped?: boolean;\n  originalNames?: string[];\n  originalCount?: number;\n}\n\nexport interface BOQUnitPrices {\n  mainMaterialSM420: number;\n  mainMaterialSM355: number;\n  subMaterial: number;\n}\n\nexport type ThicknessMergeRules = Record<number, number>;\n\n/**\n * Ported from `protected-source/boq-report.html`.\n *\n * This file is server-only by design.\n */\n\nconst steelDensity = 7850; // kg/m^3\n\n// Rolled H section names (Combination 3)\nconst rolledHCombinationNames = [\n  'H400×B200',\n  'H450×B200',\n  'H500×B200',\n  'H506×B201',\n  'H482×B300',\n  'H488×B300',\n  'H582×B300',\n  'H588×B300',\n  'H600×B200',\n];\n\nfunction isRolledHCombination(combinationName: string): boolean {\n  return rolledHCombinationNames.includes(combinationName);\n}\n\n/**\n * Group BOQ items by quantity (물량 기준 그룹핑).\n * - Sort by quantity (largest first)\n * - Items with quantity < 5% of total are grouped with similar sections\n * - Similar = H, B, tw, tf within 15% tolerance AND same combination AND same steelGrade\n */\nexport async function groupBOQItemsByQuantity(items: BOQColumnItem[]): Promise<BOQColumnItem[]> {\n  if (!items || items.length === 0) return items;\n\n  const itemsWithQuantity = items.map((item) => {\n    const quantity = item.unitWeight * item.length * item.count;\n    return { ...item, quantity };\n  });\n\n  itemsWithQuantity.sort((a, b) => (b.quantity || 0) - (a.quantity || 0));\n\n  const totalQuantity = itemsWithQuantity.reduce(\n    (sum, item) => sum + (item.quantity || 0),\n    0\n  );\n\n  const smallQuantityThreshold = totalQuantity * 0.05;\n\n  const largeQuantityItems: BOQColumnItem[] = [];\n  const smallQuantityItems: (BOQColumnItem & { quantity: number })[] = [];\n\n  itemsWithQuantity.forEach((item) => {\n    if ((item.quantity || 0) >= smallQuantityThreshold) {\n      largeQuantityItems.push(item);\n    } else {\n      smallQuantityItems.push(item as BOQColumnItem & { quantity: number });\n    }\n  });\n\n  const tolerance = 0.15;\n\n  interface SmallItemGroup {\n    items: (BOQColumnItem & { quantity: number })[];\n    totalQuantity: number;\n    totalCount: number;\n    totalLength: number;\n    names: string[];\n    representative: BOQColumnItem & { quantity: number };\n  }\n\n  const groupedSmallItems: SmallItemGroup[] = [];\n\n  smallQuantityItems.forEach((item) => {\n    if (!item.h || !item.b || !item.tw || !item.tf) {\n      largeQuantityItems.push(item);\n      return;\n    }\n\n    let foundGroup = false;\n    for (const group of groupedSmallItems) {\n      const groupItem = group.items[0];\n      if (!groupItem.h || !groupItem.b || !groupItem.tw || !groupItem.tf) continue;\n\n      const hDiff = Math.abs(item.h - groupItem.h) / groupItem.h;\n      const bDiff = Math.abs(item.b - groupItem.b) / groupItem.b;\n      const twDiff = Math.abs(item.tw - groupItem.tw) / groupItem.tw;\n      const tfDiff = Math.abs(item.tf - groupItem.tf) / groupItem.tf;\n      const sameCombination = item.combination === groupItem.combination;\n      const sameSteelGrade = item.steelGrade === groupItem.steelGrade;\n\n      if (\n        hDiff <= tolerance &&\n        bDiff <= tolerance &&\n        twDiff <= tolerance &&\n        tfDiff <= tolerance &&\n        sameCombination &&\n        sameSteelGrade\n      ) {\n        group.items.push(item);\n        group.totalQuantity += item.quantity || 0;\n        group.totalCount += item.count || 0;\n        group.totalLength += item.length * item.count || 0;\n        group.names.push(...item.names);\n        foundGroup = true;\n        break;\n      }\n    }\n\n    if (!foundGroup) {\n      groupedSmallItems.push({\n        items: [item],\n        totalQuantity: item.quantity || 0,\n        totalCount: item.count || 0,\n        totalLength: item.length * item.count || 0,\n        names: [...item.names],\n        representative: item,\n      });\n    }\n  });\n\n  const groupedItems: BOQColumnItem[] = groupedSmallItems.map((group) => {\n    const rep = group.representative;\n    const avgLength = group.totalCount > 0 ? group.totalLength / group.totalCount : rep.length;\n\n    return {\n      ...rep,\n      names:\n        group.names.length > 1\n          ? [`${group.names[0]} 외 ${group.names.length - 1}개`]\n          : group.names,\n      quantity: group.totalQuantity,\n      count: group.totalCount,\n      length: avgLength,\n      isGrouped: true,\n      originalNames: group.names,\n      originalCount: group.items.length,\n    };\n  });\n\n  groupedItems.sort((a, b) => (b.quantity || 0) - (a.quantity || 0));\n\n  return [...largeQuantityItems, ...groupedItems];\n}\n\n/**\n * Generate Plate BOQ from column items (Built-UP sections only).\n * Excludes Rolled H (Combination 3) items.\n */\nexport async function generatePlateBOQ(\n  items: BOQColumnItem[],\n  thicknessMergeRules: ThicknessMergeRules = {}\n): Promise<BOQPlateAggregatedItem[]> {\n  const builtUpItems = items.filter((item) => !isRolledHCombination(item.combination));\n\n  interface PlateData {\n    thickness: number;\n    type: string;\n    section: string;\n    width: number;\n    thickness_mm: number;\n    originalThickness: number;\n    originalWidth?: number;\n    unitWeight: number;\n    totalLength: number;\n    totalCount: number;\n    totalWeight: number;\n    steelGrade: string;\n    originalTotalWeight?: number;\n  }\n\n  const plateData: Record<string, PlateData> = {};\n\n  builtUpItems.forEach((item) => {\n    const H1 = item.H1 || item.h;\n    const H2 = item.H2 || item.h;\n    const B1 = item.B1 || item.b;\n    const B2 = item.B2 || item.b;\n\n    const originalTw1 = item.tw;\n    const originalTw2 = item.tw;\n    const originalTf1 = item.tf;\n    const originalTf2 = item.tf;\n\n    const originalH1WebWidth = H1 - 2 * originalTf1;\n    const originalH2WebWidth = H2 - 2 * originalTf2;\n\n    let tw1 = item.tw;\n    let tw2 = item.tw;\n    let tf1 = item.tf;\n    let tf2 = item.tf;\n\n    if (thicknessMergeRules[tw1]) tw1 = thicknessMergeRules[tw1];\n    if (thicknessMergeRules[tw2]) tw2 = thicknessMergeRules[tw2];\n    if (thicknessMergeRules[tf1]) tf1 = thicknessMergeRules[tf1];\n    if (thicknessMergeRules[tf2]) tf2 = thicknessMergeRules[tf2];\n\n    // H1 Web Plate (tw1)\n    const h1WebKey = `tw${tw1}-H1-Web`;\n    if (!plateData[h1WebKey]) {\n      const webWidth = H1 - 2 * tf1;\n      plateData[h1WebKey] = {\n        thickness: tw1,\n        type: 'Web',\n        section: 'H1',\n        width: webWidth,\n        thickness_mm: tw1,\n        originalThickness: originalTw1,\n        originalWidth: originalH1WebWidth,\n        unitWeight: 0,\n        totalLength: 0,\n        totalCount: 0,\n        totalWeight: 0,\n        steelGrade: item.steelGrade,\n      };\n    }\n    plateData[h1WebKey].totalLength += item.length * item.count;\n    plateData[h1WebKey].totalCount += item.count;\n\n    // H1 Flange Plate (tf1) - top and bottom (2 pieces)\n    const h1FlangeKey = `tf${tf1}-H1-Flange`;\n    if (!plateData[h1FlangeKey]) {\n      plateData[h1FlangeKey] = {\n        thickness: tf1,\n        type: 'Flange',\n        section: 'H1',\n        width: B1,\n        thickness_mm: tf1,\n        originalThickness: originalTf1,\n        unitWeight: 0,\n        totalLength: 0,\n        totalCount: 0,\n        totalWeight: 0,\n        steelGrade: item.steelGrade,\n      };\n    }\n    plateData[h1FlangeKey].totalLength += item.length * item.count * 2;\n    plateData[h1FlangeKey].totalCount += item.count * 2;\n\n    // H2 Web Plate (tw2)\n    const h2WebKey = `tw${tw2}-H2-Web`;\n    if (!plateData[h2WebKey]) {\n      const webWidth = H2 - 2 * tf2;\n      plateData[h2WebKey] = {\n        thickness: tw2,\n        type: 'Web',\n        section: 'H2',\n        width: webWidth,\n        thickness_mm: tw2,\n        originalThickness: originalTw2,\n        originalWidth: originalH2WebWidth,\n        unitWeight: 0,\n        totalLength: 0,\n        totalCount: 0,\n        totalWeight: 0,\n        steelGrade: item.steelGrade,\n      };\n    }\n    plateData[h2WebKey].totalLength += item.length * item.count;\n    plateData[h2WebKey].totalCount += item.count;\n\n    // H2 Flange Plate (tf2) - left and right (2 pieces)\n    const h2FlangeKey = `tf${tf2}-H2-Flange`;\n    if (!plateData[h2FlangeKey]) {\n      plateData[h2FlangeKey] = {\n        thickness: tf2,\n        type: 'Flange',\n        section: 'H2',\n        width: B2,\n        thickness_mm: tf2,\n        originalThickness: originalTf2,\n        unitWeight: 0,\n        totalLength: 0,\n        totalCount: 0,\n        totalWeight: 0,\n        steelGrade: item.steelGrade,\n      };\n    }\n    plateData[h2FlangeKey].totalLength += item.length * item.count * 2;\n    plateData[h2FlangeKey].totalCount += item.count * 2;\n  });\n\n  Object.keys(plateData).forEach((key) => {\n    const plate = plateData[key];\n\n    const originalThickness = plate.originalThickness || plate.thickness_mm;\n    const originalWidth = plate.originalWidth || plate.width;\n    const originalUnitWeight = (originalWidth * originalThickness * steelDensity) / 1_000_000;\n    const originalTotalWeight = originalUnitWeight * plate.totalLength;\n\n    plate.unitWeight = (plate.width * plate.thickness_mm * steelDensity) / 1_000_000;\n    plate.totalWeight = plate.unitWeight * plate.totalLength;\n\n    plate.originalTotalWeight = originalTotalWeight;\n  });\n\n  const plateByThickness: Record<string, PlateData[]> = {};\n  Object.keys(plateData).forEach((key) => {\n    const plate = plateData[key];\n    const thickness = String(plate.thickness_mm);\n    if (!plateByThickness[thickness]) plateByThickness[thickness] = [];\n    plateByThickness[thickness].push(plate);\n  });\n\n  const aggregatedPlates: BOQPlateAggregatedItem[] = [];\n  Object.keys(plateByThickness)\n    .sort((a, b) => parseFloat(a) - parseFloat(b))\n    .forEach((thickness) => {\n      const plates = plateByThickness[thickness];\n\n      const usageParts = plates.map((p) => `${p.section} ${p.type}`).join(', ');\n      const avgWidth = plates.reduce((sum, p) => sum + p.width, 0) / plates.length;\n      const totalLength = plates.reduce((sum, p) => sum + p.totalLength, 0);\n      const totalCount = plates.reduce((sum, p) => sum + p.totalCount, 0);\n      const totalWeight = plates.reduce((sum, p) => sum + p.totalWeight, 0);\n      const avgUnitWeight = totalLength > 0 ? totalWeight / totalLength : 0;\n      const steelGrade = plates[0].steelGrade;\n\n      aggregatedPlates.push({\n        thickness_mm: parseFloat(thickness),\n        avgWidth,\n        unitWeight: avgUnitWeight,\n        totalLength,\n        totalCount,\n        totalWeight,\n        usageParts,\n        steelGrade,\n        thickness: parseFloat(thickness),\n      });\n    });\n\n  return aggregatedPlates;\n}\n\n/**\n * Generate Rolled H BOQ from column items (Combination 3 only).\n */\nexport async function generateRolledHBOQ(items: BOQColumnItem[]): Promise<BOQRolledHGroup[]> {\n  const rolledHItems = items.filter((item) => isRolledHCombination(item.combination));\n\n  const groupedData: Record<string, BOQRolledHGroup> = {};\n\n  rolledHItems.forEach((item) => {\n    const key = `${item.combination}-${item.length.toFixed(2)}`;\n    if (!groupedData[key]) {\n      groupedData[key] = {\n        combination: item.combination,\n        length: item.length,\n        count: 0,\n        unitWeight: item.unitWeight,\n        totalWeight: 0,\n        names: [],\n        steelGrade: item.steelGrade,\n      };\n    }\n    groupedData[key].count += item.count;\n    groupedData[key].totalWeight += item.unitWeight * item.length * item.count;\n    groupedData[key].names.push(...item.names);\n  });\n\n  return Object.values(groupedData);\n}\n\n/**\n * Group Rolled H items by quantity (similar to groupBOQItemsByQuantity).\n */\nexport async function groupRolledHItemsByQuantity(groups: BOQRolledHGroup[]): Promise<BOQRolledHGroup[]> {\n  if (!groups || groups.length === 0) return groups;\n\n  groups.sort((a, b) => (b.totalWeight || 0) - (a.totalWeight || 0));\n\n  const totalQuantity = groups.reduce((sum, group) => sum + (group.totalWeight || 0), 0);\n  const smallQuantityThreshold = totalQuantity * 0.05;\n\n  const largeQuantityItems: BOQRolledHGroup[] = [];\n  const smallQuantityItems: BOQRolledHGroup[] = [];\n\n  groups.forEach((group) => {\n    if ((group.totalWeight || 0) >= smallQuantityThreshold) {\n      largeQuantityItems.push(group);\n    } else {\n      smallQuantityItems.push(group);\n    }\n  });\n\n  const tolerance = 0.15;\n\n  interface SmallRolledHGroup {\n    items: BOQRolledHGroup[];\n    totalWeight: number;\n    totalCount: number;\n    names: string[];\n    representative: BOQRolledHGroup;\n  }\n\n  const groupedSmallItems: SmallRolledHGroup[] = [];\n\n  smallQuantityItems.forEach((group) => {\n    if (!group.combination || !group.length) {\n      largeQuantityItems.push(group);\n      return;\n    }\n\n    let foundGroup = false;\n    for (const g of groupedSmallItems) {\n      const gGroup = g.items[0];\n      if (!gGroup.combination || !gGroup.length) continue;\n\n      const sameCombination = group.combination === gGroup.combination;\n      const lengthDiff = Math.abs(group.length - gGroup.length) / gGroup.length;\n\n      if (sameCombination && lengthDiff <= tolerance) {\n        g.items.push(group);\n        g.totalWeight += group.totalWeight || 0;\n        g.totalCount += group.count || 0;\n        g.names = [...new Set([...g.names, ...group.names])];\n        foundGroup = true;\n        break;\n      }\n    }\n\n    if (!foundGroup) {\n      groupedSmallItems.push({\n        items: [group],\n        totalWeight: group.totalWeight || 0,\n        totalCount: group.count || 0,\n        names: [...group.names],\n        representative: group,\n      });\n    }\n  });\n\n  const groupedItems: BOQRolledHGroup[] = groupedSmallItems.map((g) => {\n    const rep = g.representative;\n    return {\n      ...rep,\n      names: g.names.length > 1 ? [`${g.names[0]} 외 ${g.names.length - 1}개`] : g.names,\n      totalWeight: g.totalWeight,\n      count: g.totalCount,\n      isGrouped: true,\n      originalNames: g.names,\n      originalCount: g.items.length,\n    };\n  });\n\n  groupedItems.sort((a, b) => (b.totalWeight || 0) - (a.totalWeight || 0));\n\n  return [...largeQuantityItems, ...groupedItems];\n}\n\n/**\n * Calculate BOQ totals and amounts.\n */\nexport interface BOQTotals {\n  totalCount: number;\n  totalArea: number;\n  totalWeight: number;\n  totalColumnAmount: number;\n}\n\nexport async function calculateBOQTotals(items: BOQColumnItem[], unitPrices: BOQUnitPrices): Promise<BOQTotals> {\n  let totalCount = 0;\n  let totalArea = 0;\n  let totalWeight = 0;\n  let totalColumnAmount = 0;\n\n  items.forEach((item) => {\n    const itemWeight = item.unitWeight * item.length * item.count;\n    totalCount += item.count;\n    totalArea += item.area * item.count;\n    totalWeight += itemWeight;\n\n    const weightInTon = itemWeight / 1000;\n    let unitPrice = unitPrices.mainMaterialSM420;\n\n    if (item.steelGrade === 'SM355' || item.steelGrade.includes('SM355')) {\n      unitPrice = unitPrices.mainMaterialSM355;\n    } else if (item.steelGrade === 'SM420' || item.steelGrade.includes('SM420')) {\n      unitPrice = unitPrices.mainMaterialSM420;\n    }\n\n    totalColumnAmount += weightInTon * unitPrice;\n  });\n\n  return { totalCount, totalArea, totalWeight, totalColumnAmount };\n}\n\n/**\n * Calculate sub-material (소부재) BOQ.\n * Sub-material is typically 15% of total steel weight.\n */\nexport interface SubMaterialBOQItem {\n  type: string;\n  spec: string;\n  unit: string;\n  quantity: number | null;\n  steelGrade: string;\n  mainMaterialWeight: number;\n  surcharge: number;\n  unitPrice: number;\n  amount: number;\n  remark: string;\n}\n\nexport async function calculateSubMaterialBOQ(\n  columnTotalWeight: number,\n  unitPrices: BOQUnitPrices,\n  surchargeRate: number = 0.15\n): Promise<SubMaterialBOQItem[]> {\n  const surcharge = columnTotalWeight * surchargeRate;\n  const surchargeInTon = surcharge / 1000;\n  const amount = surchargeInTon * unitPrices.subMaterial;\n\n  return [\n    {\n      type: '3 PLATE',\n      spec: '접합부',\n      unit: 'Ton',\n      quantity: null,\n      steelGrade: 'SM355/SM420',\n      mainMaterialWeight: columnTotalWeight,\n      surcharge,\n      unitPrice: unitPrices.subMaterial,\n      amount,\n      remark: '전체 철골물량의 15%',\n    },\n  ];\n}\n\n/**\n * Group Plate items by quantity (similar to groupBOQItemsByQuantity).\n */\nexport async function groupPlateItemsByQuantity(\n  plates: BOQPlateAggregatedItem[],\n  thicknessMergeRules: ThicknessMergeRules = {}\n): Promise<BOQPlateAggregatedItem[]> {\n  if (!plates || plates.length === 0) return plates;\n\n  plates.sort((a, b) => (b.totalWeight || 0) - (a.totalWeight || 0));\n\n  const totalQuantity = plates.reduce((sum, plate) => sum + (plate.totalWeight || 0), 0);\n  const smallQuantityThreshold = totalQuantity * 0.05;\n\n  const largeQuantityItems: BOQPlateAggregatedItem[] = [];\n  const smallQuantityItems: BOQPlateAggregatedItem[] = [];\n\n  plates.forEach((plate) => {\n    if ((plate.totalWeight || 0) >= smallQuantityThreshold) {\n      largeQuantityItems.push(plate);\n    } else {\n      smallQuantityItems.push(plate);\n    }\n  });\n\n  const tolerance = 0.15;\n\n  interface SmallPlateGroup {\n    items: BOQPlateAggregatedItem[];\n    totalWeight: number;\n    totalCount: number;\n    totalLength: number;\n    usageParts: string;\n    representative: BOQPlateAggregatedItem;\n    originalThicknessMap: Record<number, number>;\n  }\n\n  const groupedSmallItems: SmallPlateGroup[] = [];\n\n  smallQuantityItems.forEach((plate) => {\n    if (!plate.thickness_mm || !plate.avgWidth) {\n      largeQuantityItems.push(plate);\n      return;\n    }\n\n    let adjustedThickness = plate.thickness_mm;\n    if (thicknessMergeRules[plate.thickness_mm]) {\n      adjustedThickness = thicknessMergeRules[plate.thickness_mm];\n    }\n\n    let foundGroup = false;\n    for (const group of groupedSmallItems) {\n      const groupPlate = group.items[0];\n      if (!groupPlate.thickness_mm || !groupPlate.avgWidth) continue;\n\n      const thicknessMatch = adjustedThickness === groupPlate.thickness_mm;\n      const thicknessDiff = Math.abs(adjustedThickness - groupPlate.thickness_mm) / groupPlate.thickness_mm;\n      const widthDiff = Math.abs(plate.avgWidth - groupPlate.avgWidth) / groupPlate.avgWidth;\n\n      if (thicknessMatch || (thicknessDiff <= tolerance && widthDiff <= tolerance)) {\n        group.items.push(plate);\n        group.totalWeight += plate.totalWeight || 0;\n        group.totalCount += plate.totalCount || 0;\n        group.totalLength += plate.totalLength || 0;\n        group.usageParts = [...new Set([...group.usageParts.split(', '), ...plate.usageParts.split(', ')])].join(\n          ', '\n        );\n\n        const originalThick = plate.thickness_mm;\n        if (!group.originalThicknessMap[originalThick]) {\n          group.originalThicknessMap[originalThick] = 0;\n        }\n        group.originalThicknessMap[originalThick] += plate.totalWeight || 0;\n\n        foundGroup = true;\n        break;\n      }\n    }\n\n    if (!foundGroup) {\n      const originalThick = plate.thickness_mm;\n      groupedSmallItems.push({\n        items: [plate],\n        totalWeight: plate.totalWeight || 0,\n        totalCount: plate.totalCount || 0,\n        totalLength: plate.totalLength || 0,\n        usageParts: plate.usageParts,\n        representative: plate,\n        originalThicknessMap: { [originalThick]: plate.totalWeight || 0 },\n      });\n    }\n  });\n\n  const groupedItems: BOQPlateAggregatedItem[] = groupedSmallItems.map((group) => {\n    const rep = group.representative;\n    const avgUnitWeight = group.totalLength > 0 ? group.totalWeight / group.totalLength : rep.unitWeight;\n\n    const mergeInfoParts: string[] = [];\n    Object.keys(group.originalThicknessMap)\n      .sort((a, b) => parseFloat(a) - parseFloat(b))\n      .forEach((thick) => {\n        const weight = group.originalThicknessMap[parseFloat(thick)];\n        mergeInfoParts.push(`${thick}mm: ${weight.toFixed(2)}kg`);\n      });\n    const mergeInfo =\n      mergeInfoParts.length > 0\n        ? `${mergeInfoParts.join(', ')} → ${rep.thickness_mm}mm: ${group.totalWeight.toFixed(2)}kg`\n        : '';\n\n    return {\n      ...rep,\n      usageParts: group.usageParts,\n      totalWeight: group.totalWeight,\n      totalCount: group.totalCount,\n      totalLength: group.totalLength,\n      unitWeight: avgUnitWeight,\n      mergeInfo,\n    };\n  });\n\n  groupedItems.sort((a, b) => (b.totalWeight || 0) - (a.totalWeight || 0));\n  return [...largeQuantityItems, ...groupedItems];\n}\n","'use server';\n\nimport { calculateSection, type CrossHSectionCalcInput, type CrossHSectionCalcResult } from '../lib/calculations/cross-h-column';\nimport {\n  findOptimalSection as findOptimalSectionCalc,\n  type OptimalSectionSearchInput,\n  type OptimalSectionSearchResult,\n} from '../lib/calculations/steel-section';\nimport {\n  calculateBOQTotals,\n  generatePlateBOQ,\n  type BOQColumnItem,\n  type BOQPlateAggregatedItem,\n  type BOQTotals,\n  type BOQUnitPrices,\n} from '../lib/calculations/boq';\n\n/**\n * Server Actions wrapper for calculation modules.\n *\n * IMPORTANT: keep this file server-only to prevent calculation code from\n * being included in client bundles.\n */\n\nexport async function calculateCrossHColumn(input: CrossHSectionCalcInput): Promise<CrossHSectionCalcResult> {\n  return calculateSection(input);\n}\n\nexport async function findOptimalSection(input: OptimalSectionSearchInput): Promise<OptimalSectionSearchResult> {\n  return findOptimalSectionCalc(input);\n}\n\nexport interface GenerateBOQInput {\n  items: BOQColumnItem[];\n  unitPrices: BOQUnitPrices;\n  thicknessMergeRules?: Record<number, number>;\n}\n\nexport interface GenerateBOQResult {\n  totals: BOQTotals;\n  plates: BOQPlateAggregatedItem[];\n}\n\nexport async function generateBOQ(input: GenerateBOQInput): Promise<GenerateBOQResult> {\n  const totals = await calculateBOQTotals(input.items, input.unitPrices);\n  const plates = await generatePlateBOQ(input.items, input.thicknessMergeRules ?? {});\n  return { totals, plates };\n}\n"],"names":[],"mappings":"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"}