<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto Find Section : Cross H ê¸°ë‘¥ ìë™êµ¬ì¡°ê³„ì‚° ë° ì² ê³¨ BOQ ì‚°ì¶œ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #1e3a5f, #2d5a87);
            color: white;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .header a {
            color: rgba(255,255,255,0.8);
            text-decoration: none;
            font-size: 14px;
            padding: 8px 16px;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 4px;
            transition: all 0.2s;
        }

        .header a:hover {
            background: rgba(255,255,255,0.1);
            color: white;
        }

        .main-content {
            padding: 30px;
        }

        .section {
            background: #f8fafc;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #e2e8f0;
        }

        .section-title {
            font-size: 18px;
            font-weight: 600;
            color: #1e3a5f;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .input-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .input-group {
            display: flex;
            flex-direction: column;
        }

        .input-group label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .input-group input,
        .input-group select {
            padding: 8px 12px;
            border: 1px solid #cbd5e0;
            border-radius: 4px;
            font-size: 14px;
        }

        .input-group input:focus,
        .input-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        /* í•˜ì¤‘ ì…ë ¥ í…Œì´ë¸” ìŠ¤íƒ€ì¼ */
        .load-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        .load-table th,
        .load-table td {
            padding: 10px;
            text-align: center;
            border: 1px solid #e2e8f0;
        }

        .load-table th {
            background: #1e3a5f;
            color: white;
            font-weight: 600;
            font-size: 12px;
        }

        .load-table td input {
            width: 100%;
            padding: 6px;
            border: 1px solid #cbd5e0;
            border-radius: 4px;
            font-size: 13px;
        }

        .load-table tbody tr:nth-child(even) {
            background: #f8fafc;
        }

        .load-table tbody tr:hover {
            background: #e8f4f8;
        }

        /* ê²°ê³¼ í…Œì´ë¸” ìŠ¤íƒ€ì¼ */
        .result-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 11px;
        }

        .result-table th,
        .result-table td {
            padding: 8px 6px;
            text-align: center;
            border: 1px solid #e2e8f0;
        }

        .result-table th {
            background: #1e3a5f;
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
            white-space: nowrap;
        }

        .result-table tbody tr:nth-child(even) {
            background: #f8fafc;
        }

        .result-table tbody tr:hover {
            background: #e8f4f8;
        }

        /* BOQ í…Œì´ë¸” ìŠ¤íƒ€ì¼ */
        .boq-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 12px;
        }

        .boq-table th,
        .boq-table td {
            padding: 10px;
            text-align: center;
            border: 1px solid #e2e8f0;
        }

        .boq-table th {
            background: #2d5a87;
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .boq-table tbody tr:nth-child(even) {
            background: #f8fafc;
        }

        .boq-table tbody tr:hover {
            background: #e8f4f8;
        }

        .boq-table .total-row {
            background: #e8f4f8;
            font-weight: 600;
            color: #1e3a5f;
        }

        .boq-section {
            background: #f8fafc;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #e2e8f0;
            display: none;
        }

        .boq-section.show {
            display: block;
        }

        .btn-secondary {
            background: #667eea;
            color: white;
        }

        .btn-secondary:hover {
            background: #5568d3;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Auto Find Section : Cross H ê¸°ë‘¥ ìë™êµ¬ì¡°ê³„ì‚° ë° ì² ê³¨ BOQ ì‚°ì¶œ</h1>
            <a href="crossHcolumnCalculator.html">â† ê³„ì‚°ê¸°ë¡œ ëŒì•„ê°€ê¸°</a>
        </div>

        <div class="main-content">
            <!-- ê³µí†µ ì„¤ì • -->
            <div class="section">
                <div class="section-title">ê³µí†µ ì„¤ì •</div>
                <div class="input-row">
                    <div class="input-group">
                        <label>ê¸°ë‘¥ ê°œìˆ˜</label>
                        <input type="number" id="columnCount" value="3" min="1" max="20" onchange="updateLoadTable()" oninput="updateLoadTable()">
                    </div>
                    <div class="input-group">
                        <label>Kx</label>
                        <input type="number" id="Kx" value="0.8" step="0.1" min="0.1">
                    </div>
                    <div class="input-group">
                        <label>Ky</label>
                        <input type="number" id="Ky" value="0.8" step="0.1" min="0.1">
                    </div>
                    <div class="input-group">
                        <label>Kz</label>
                        <input type="number" id="Kz" value="0.8" step="0.1" min="0.1">
                    </div>
                    <div class="input-group">
                        <label>ê°•ì¢…</label>
                        <select id="steelGrade">
                            <option value="275">SS275</option>
                            <option value="355">SM355</option>
                            <option value="420" selected>SM420</option>
                        </select>
                    </div>
                </div>
                <div style="margin-top: 15px; padding: 10px; background: #e8f4f8; border-radius: 4px; font-size: 12px;">
                    <strong>ê³ ì • ì¹˜ìˆ˜:</strong> ë‘ ê°€ì§€ ì¡°í•©ì„ ëª¨ë‘ ê³„ì‚°í•˜ì—¬ ë” ì‘ì€ ë‹¨ë©´ì ì„ ì„ íƒí•©ë‹ˆë‹¤.<br>
                    â€¢ ì¡°í•© 1: H1=500, H2=500, B1=300, B2=300<br>
                    â€¢ ì¡°í•© 2: H1=450, H2=450, B1=250, B2=250<br>
                    â€¢ tw1=tw2 (8~16mm), tf1=tf2 (10~20mm)
                </div>
            </div>


            <!-- í•˜ì¤‘ ì…ë ¥ -->
            <div class="section">
                <div class="section-title">í•˜ì¤‘ ì…ë ¥</div>
                <table class="load-table">
                    <thead>
                        <tr>
                            <th>No.</th>
                            <th>ê¸°ë‘¥ ì´ë¦„</th>
                            <th>Pu (kN)</th>
                            <th>Mux (kNÂ·m)</th>
                            <th>Muy (kNÂ·m)</th>
                        </tr>
                    </thead>
                    <tbody id="loadTableBody">
                        <!-- JavaScriptë¡œ ë™ì  ìƒì„± -->
                    </tbody>
                </table>
            </div>

            <!-- ê³„ì‚° ë° ê²°ê³¼ -->
            <div class="section">
                <div class="section-title">ê³„ì‚° ë° ê²°ê³¼</div>
                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button class="btn btn-primary" onclick="calculateAll()" style="flex: 1;">
                        Auto Find Section Result
                    </button>
                    <button class="btn btn-secondary" onclick="printCalculationSheet()" style="flex: 1;">
                        ğŸ“„ ê³„ì‚°ì„œ ì¶œë ¥
                    </button>
                    <button class="btn" onclick="generateBOQ()" style="flex: 1; background: #38a169; color: white;">
                        ğŸ“‹ BOQ ì‚°ì¶œ
                    </button>
                </div>
                <div style="overflow-x: auto;">
                    <table class="result-table" id="resultTable">
                        <thead>
                            <tr>
                                <th rowspan="2">No.</th>
                                <th rowspan="2">ê¸°ë‘¥ëª…</th>
                                <th rowspan="2">Pu (kN)</th>
                                <th rowspan="2">P-M-M</th>
                                <th rowspan="2">ê°•ì¢…</th>
                                <th rowspan="2">ì¡°í•©</th>
                                <th colspan="6">ê·œê²©</th>
                                <th rowspan="2">ë‹¨ë©´ì <br>(mmÂ²)</th>
                                <th rowspan="2">ë‹¨ì¤‘<br>(kg/m)</th>
                            </tr>
                            <tr>
                                <th>K</th>
                                <th>L</th>
                                <th>H</th>
                                <th>B</th>
                                <th>tw</th>
                                <th>tf</th>
                            </tr>
                        </thead>
                        <tbody id="resultTableBody">
                            <!-- ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- BOQ ì‚°ì¶œ -->
            <div class="section boq-section" id="boqSection">
                <div class="section-title">BOQ (Bill of Quantities) - ê³µì‚¬ ìˆ˜ëŸ‰ ì‚°ì¶œì„œ</div>
                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button class="btn" onclick="printBOQ()" style="background: #38a169; color: white;">
                        ğŸ–¨ï¸ BOQ ì¸ì‡„
                    </button>
                    <button class="btn" onclick="exportBOQToCSV()" style="background: #667eea; color: white;">
                        ğŸ“¥ CSV ë‹¤ìš´ë¡œë“œ
                    </button>
                </div>
                <div style="overflow-x: auto;">
                    <table class="boq-table" id="boqTable">
                        <thead>
                            <tr>
                                <th>No.</th>
                                <th>ê¸°ë‘¥ëª…</th>
                                <th>ì¡°í•©</th>
                                <th>ê·œê²©</th>
                                <th>H<br>(mm)</th>
                                <th>B<br>(mm)</th>
                                <th>tw<br>(mm)</th>
                                <th>tf<br>(mm)</th>
                                <th>ë‹¨ë©´ì <br>(mmÂ²)</th>
                                <th>ë‹¨ì¤‘<br>(kg/m)</th>
                                <th>ê¸¸ì´<br>(m)</th>
                                <th>ê°œìˆ˜</th>
                                <th>ì´ ì¤‘ëŸ‰<br>(kg)</th>
                                <th>ê°•ì¢…</th>
                            </tr>
                        </thead>
                        <tbody id="boqTableBody">
                            <!-- BOQ ë°ì´í„°ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤ -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ë‘ ê°€ì§€ ì¡°í•© ì •ì˜
        const combinations = [
            { H1: 500, H2: 500, B1: 300, B2: 300, name: 'H500Ã—B300' },
            { H1: 450, H2: 450, B1: 250, B2: 250, name: 'H450Ã—B250' }
        ];
        
        const twRange = [8, 9, 10, 11, 12, 13, 14, 15, 16]; // tw: 8-16mm
        const tfRange = [10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]; // tf: 10-20mm
        const steelDensity = 7850; // kg/mÂ³

        // í•˜ì¤‘ ë°ì´í„° ë°°ì—´
        let columnData = [];
        // ê³„ì‚° ê²°ê³¼ ë°°ì—´ (ì „ì—­)
        let currentResults = [];

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', function() {
            updateLoadTable();
        });

        // í•˜ì¤‘ ì…ë ¥ í…Œì´ë¸” ì—…ë°ì´íŠ¸ (ê¸°ë‘¥ ê°œìˆ˜ì— ë”°ë¼ ë™ì  ìƒì„±)
        function updateLoadTable() {
            const tbody = document.getElementById('loadTableBody');
            if (!tbody) return;
            
            const count = parseInt(document.getElementById('columnCount').value) || 3;
            
            // ê¸°ì¡´ ë°ì´í„° ë³´ì¡´
            const existingData = {};
            columnData.forEach(col => {
                existingData[col.no] = col;
            });
            
            tbody.innerHTML = '';
            columnData = [];
            
            // ì…ë ¥í•œ ê°œìˆ˜ë§Œí¼ í–‰ ìƒì„±
            for (let i = 1; i <= count; i++) {
                const existing = existingData[i];
                const colName = `KC${i}`;
                columnData.push({
                    no: i,
                    name: existing?.name || colName,
                    pu: existing?.pu || 0,
                    mux: existing?.mux || 0,
                    muy: existing?.muy || 0
                });
                
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td style="font-weight: 600; color: #667eea; text-align: center;">${i}</td>
                    <td><input type="text" id="col${i}_name" value="${existing?.name || colName}" 
                               placeholder="ê¸°ë‘¥ ì´ë¦„" style="width: 100%; padding: 6px; border: 1px solid #cbd5e0; border-radius: 4px;"
                               onchange="updateColumnData(${i}, 'name', this.value)"></td>
                    <td><input type="number" id="col${i}_Pu" value="${existing?.pu || 0}" step="0.1" placeholder="Pu" 
                               style="width: 100%; padding: 6px; border: 1px solid #cbd5e0; border-radius: 4px;"
                               onchange="updateColumnData(${i}, 'pu', this.value)"></td>
                    <td><input type="number" id="col${i}_Mux" value="${existing?.mux || 0}" step="0.1" placeholder="Mux" 
                               style="width: 100%; padding: 6px; border: 1px solid #cbd5e0; border-radius: 4px;"
                               onchange="updateColumnData(${i}, 'mux', this.value)"></td>
                    <td><input type="number" id="col${i}_Muy" value="${existing?.muy || 0}" step="0.1" placeholder="Muy" 
                               style="width: 100%; padding: 6px; border: 1px solid #cbd5e0; border-radius: 4px;"
                               onchange="updateColumnData(${i}, 'muy', this.value)"></td>
                `;
                tbody.appendChild(row);
            }
        }

        // ê¸°ì¡´ updateColumnTable í•¨ìˆ˜ ì œê±°í•˜ê³  updateLoadTable ì‚¬ìš©

        // í•˜ì¤‘ ë°ì´í„° ì—…ë°ì´íŠ¸
        function updateColumnData(no, field, value) {
            const col = columnData.find(c => c.no === no);
            if (col) {
                if (field === 'name') {
                    col.name = value;
                } else if (field === 'pu') {
                    col.pu = parseFloat(value) || 0;
                } else if (field === 'mux') {
                    col.mux = parseFloat(value) || 0;
                } else if (field === 'muy') {
                    col.muy = parseFloat(value) || 0;
                }
            }
        }

        // ê¸¸ì´ íƒ€ì…ë³„ Lx, Ly ê°€ì ¸ì˜¤ê¸° (ê¸°ë³¸ê°’ ì‚¬ìš©)
        function getLengthsForType(type) {
            // ê¸°ë³¸ê°’ 4.5m ì‚¬ìš©
            const Lx = 4.5;
            const Ly = 4.5;
            return { Lx: Lx * 1000, Ly: Ly * 1000 }; // m to mm
        }

        // ì¼ë°˜ H-beam ë‹¨ë©´ ê³„ì‚° í•¨ìˆ˜
        function calculateSingleHBeam(tw, tf, Fy, E, nu, Kx, Ky, Kz, Lx, Ly, Pu, Mux, Muy) {
            const h = H_single;
            const b = B_single;
            const r = 0; // Built-up ë¶€ì¬
            
            // ë‹¨ë©´ ê³„ì‚°
            const hw = h - 2 * tf;
            const d = h / 2 - tf / 2;
            
            // ë‹¨ë©´ì 
            const ag1 = b * tf;
            const ag2 = b * tf;
            const ag3 = hw * tw;
            const ag4 = 4 * (r * r - Math.PI * r * r / 4);
            const area = ag1 + ag2 + ag3 + ag4;
            
            // ê´€ì„±ëª¨ë©˜íŠ¸
            const Ix1 = 1/12 * b * Math.pow(tf, 3) + ag1 * Math.pow(d, 2);
            const Ix2 = 1/12 * b * Math.pow(tf, 3) + ag1 * Math.pow(d, 2);
            const Ix3 = 1/12 * tw * Math.pow(hw, 3);
            const Ix = Ix1 + Ix2 + Ix3;
            
            const Iy1 = 1/12 * tf * Math.pow(b, 3);
            const Iy2 = 1/12 * tf * Math.pow(b, 3);
            const Iy3 = 1/12 * hw * Math.pow(tw, 3);
            const Iy = Iy1 + Iy2 + Iy3;
            
            // íšŒì „ë°˜ê²½
            const ix = Math.sqrt(Ix / area);
            const iy = Math.sqrt(Iy / area);
            
            // íƒ„ì„± ë‹¨ë©´ê³„ìˆ˜
            const sx = Ix / (h / 2);
            const sy = Iy / (b / 2);
            
            // ì†Œì„± ë‹¨ë©´ê³„ìˆ˜
            // Zx = B*tf*(H-tf) + tw*(H-2*tf)^2/4
            const zx = b * tf * (h - tf) + tw * Math.pow(hw, 2) / 4;
            
            // Zy = tf*B^2/2 + (H-2*tf)*tw^2/4
            const zy = tf * Math.pow(b, 2) / 2 + hw * Math.pow(tw, 2) / 4;
            
            // ë¹„í‹€ë¦¼ ìƒìˆ˜
            const J = (2 * b * Math.pow(tf, 3) + h * Math.pow(tw, 3)) / 3;
            
            // ì¢Œêµ´ ìƒìˆ˜
            const cw = Iy * Math.pow(h - tf, 2) / 4;
            
            // Plate thickness ratio for compression (flange)
            const lcfr = 0.56 * Math.sqrt(E / Fy);
            const lcf = b / (2 * tf);
            const isSlenderFlange = lcf > lcfr;
            
            // ì„¸ì¥ë¹„
            const lambdaX = Kx * Lx / ix;
            const lambdaY = Ky * Ly / iy;
            const lambda = Math.max(lambdaX, lambdaY);
            
            // ì¢Œêµ´ ì‘ë ¥
            const Fe1 = Math.pow(Math.PI, 2) * E / Math.pow(lambda, 2);
            const G = E / (2 * (1 + nu));
            const Fe2 = (Math.pow(Math.PI, 2) * E * cw / Math.pow(Kz * Lx, 2) + G * J) / (Ix + Iy);
            const Fe = Math.min(Fe1, Fe2);
            const Fcr = Math.pow(0.658, Fy / Fe) * Fy;
            
            // ì••ì¶• ê°•ë„
            const phi_c = 0.9;
            const phi_Pn = phi_c * area * Fcr / 1000; // kN
            
            // íœ¨ ê°•ë„
            const Mpx = Math.min(Fy * zx, 1.6 * Fy * sx) / 1000000; // kN.m
            const Mpy = Math.min(Fy * zy, 1.6 * Fy * sy) / 1000000; // kN.m
            const phi_b = 0.9;
            const phi_Mnx = phi_b * Mpx;
            const phi_Mny = phi_b * Mpy;
            
            // ë¹„ìœ¨ ê³„ì‚°
            const ratio_comp = Pu / phi_Pn;
            const ratio_bendX = phi_Mnx > 0 ? Mux / phi_Mnx : 0;
            const ratio_bendY = phi_Mny > 0 ? Muy / phi_Mny : 0;
            
            // P-M-M ì¡°í•©
            let ratio_pmm;
            if (ratio_comp >= 0.2) {
                ratio_pmm = ratio_comp + (8/9) * (ratio_bendX + ratio_bendY);
            } else {
                ratio_pmm = ratio_comp / 2 + (ratio_bendX + ratio_bendY);
            }
            
            const isCompressiveNG = phi_Pn < Pu;
            
            return { phi_Pn, area, ratio_pmm, tw, tf, lcf, lcfr, isSlenderFlange, isCompressiveNG };
        }
        
        // Cross H ë‹¨ë©´ ê³„ì‚° í•¨ìˆ˜ (H, B íŒŒë¼ë¯¸í„° ì¶”ê°€)
        function calculateSection(tw, tf, Fy, E, nu, Kx, Ky, Kz, Lx, Ly, Pu, Mux, Muy, h1, h2, b1, b2) {
            // ===== ì…ë ¥ê°’ ê°€ì ¸ì˜¤ê¸° (Main Calculator quickCalculateì™€ ë™ì¼) =====
            const tw1 = tw;
            const tf1 = tf;
            const r1 = 0; // Built-up ë¶€ì¬
            
            const tw2 = tw;
            const tf2 = tf;
            const r2 = 0; // Built-up ë¶€ì¬

            // ===== HBeam Class calculations (Main Calculatorì™€ ì™„ì „íˆ ë™ì¼) =====
            const hw3 = h1 - 2 * tf1;
            const hw6 = h2 - 2 * tf2;
            const d1 = h1/2 - tf1/2;
            const d4 = h2/2 - tf2/2;

            // Total section area - Cross H section
            const ag1 = b1 * tf1;
            const ag2 = b1 * tf1;
            const ag3 = hw3 * tw1;
            const ag4 = b2 * tf2;
            const ag5 = b2 * tf2;
            const ag6 = hw6 * tw2;
            const ag7 = 4 * (r1*r1 - Math.PI * r1*r1 / 4);
            const ag8 = 4 * (r2*r2 - Math.PI * r2*r2 / 4);
            const ag9 = tw1 * tw2;
            const area = ag1 + ag2 + ag3 + ag4 + ag5 + ag6 + ag7 + ag8 - ag9;

            // Second inertia moment X-axis
            const Ix1 = 1/12 * b1 * Math.pow(tf1, 3) + ag1 * Math.pow(d1, 2);
            const Ix2 = 1/12 * b1 * Math.pow(tf1, 3) + ag1 * Math.pow(d1, 2);
            const Ix3 = 1/12 * tw1 * Math.pow(hw3, 3);
            const Ix4 = 1/12 * tf2 * Math.pow(b2, 3);
            const Ix5 = 1/12 * tf2 * Math.pow(b2, 3);
            const Ix6 = 1/12 * hw6 * Math.pow(tw2, 3);
            const Ix = Ix1 + Ix2 + Ix3 + Ix4 + Ix5 + Ix6;

            // Second inertia moment Y-axis
            const Iy4 = 1/12 * b2 * Math.pow(tf2, 3) + ag4 * Math.pow(d4, 2);
            const Iy5 = 1/12 * b2 * Math.pow(tf2, 3) + ag4 * Math.pow(d4, 2);
            const Iy6 = 1/12 * tw2 * Math.pow(hw6, 3);
            const Iy1 = 1/12 * tf1 * Math.pow(b1, 3);
            const Iy2 = 1/12 * tf1 * Math.pow(b1, 3);
            const Iy3 = 1/12 * hw3 * Math.pow(tw2, 3);
            const Iy = Iy1 + Iy2 + Iy3 + Iy4 + Iy5 + Iy6;

            // Radius of gyration
            const ix = Math.sqrt(Ix / area);
            const iy = Math.sqrt(Iy / area);

            // Elastic section modulus
            const sx = Ix / (h1 / 2);
            const sy = Iy / (h2 / 2);

            // Plastic section modulus Zx
            const Zx1 = (b1 * tf1) * d1;
            const Zx2 = (b1 * tf1) * d1;
            const Zx3 = (tw1 * hw3/2) * hw3/4;
            const Zx4 = (tw1 * hw3/2) * hw3/4;
            const Zx5 = (b2*b2 * tf2 / 2);
            const Zx6 = (tw2 * hw6 / 8) * 2;
            const zx = Zx1 + Zx2 + Zx3 + Zx4 + Zx5 + Zx6;

            // Plastic section modulus Zy
            const Zy1 = (b2 * tf2) * d4;
            const Zy2 = (b2 * tf2) * d4;
            const Zy3 = (tw2 * hw6/2) * hw6/4;
            const Zy4 = (tw2 * hw6/2) * hw6/4;
            const Zy5 = (b1*b1 * tf1 / 2);
            const Zy6 = (tw1 * hw3 / 8) * 2;
            const zy = Zy1 + Zy2 + Zy3 + Zy4 + Zy5 + Zy6;

            // Torsional constant J
            const J1 = (2*b1 * Math.pow(tf1, 3) + h1*Math.pow(tw1, 3)) / 3;
            const J2 = (2*b2 * Math.pow(tf2, 3) + h2*Math.pow(tw2, 3)) / 3;
            const J = J1 + J2;

            // Warping constant Cw
            const cw = Iy * Math.pow(h1 - tf1, 2) / 4;

            // ===== Column Class calculations =====
            // Plate thickness ratio for compression (Minor Section)
            const lcfr = 0.56 * Math.sqrt(E / Fy); // Î»cfr = 0.56 âˆš(E / Fy)
            const lcf = b2 / (2 * tf2); // Î»cf = B2 / 2 / tf2
            const isSlenderFlange = lcf > lcfr; // Î»cf > Î»cfrì´ë©´ Slender
            
            // Slenderness ratio
            const lambdaX = Kx * Lx / ix;
            const lambdaY = Ky * Ly / iy;
            const lambda = Math.max(lambdaX, lambdaY);

            // Flexural Buckling Stress Fe1
            const Fe1 = Math.pow(Math.PI, 2) * E / Math.pow(lambda, 2);

            // Torsional Buckling Stress Fe2
            const G = E / (2 * (1 + nu));
            const Fe2 = (Math.pow(Math.PI, 2) * E * cw / Math.pow(Kz * Lx, 2) + G * J) / (Ix + Iy);

            // Critical stress Fcr
            const Fe = Math.min(Fe1, Fe2);
            const Fcr = Math.pow(0.658, Fy / Fe) * Fy;

            // Compressive Strength phi_Pn
            const phi_c = 0.9;
            const phi_Pn = phi_c * area * Fcr / 1000; // kN

            // Flexural Strength - Mpx, Mpy
            const Mpx = Math.min(Fy * zx, 1.6 * Fy * sx) / 1000000; // kN.m
            const Mpy = Math.min(Fy * zy, 1.6 * Fy * sy) / 1000000; // kN.m
            const phi_b = 0.9;
            const phi_Mnx = phi_b * Mpx;
            const phi_Mny = phi_b * Mpy;

            // ===== ë¹„ìœ¨ ê³„ì‚° =====
            const ratio_comp = Pu / phi_Pn;
            const ratio_bendX = phi_Mnx > 0 ? Mux / phi_Mnx : 0;
            const ratio_bendY = phi_Mny > 0 ? Muy / phi_Mny : 0;

            // P-M-M ì¡°í•©
            let ratio_pmm;
            if (ratio_comp >= 0.2) {
                ratio_pmm = ratio_comp + (8/9) * (ratio_bendX + ratio_bendY);
            } else {
                ratio_pmm = ratio_comp / 2 + (ratio_bendX + ratio_bendY);
            }

            // ë””ë²„ê¹…: Main Calculatorì™€ ë¹„êµ (tw=9, tf=10, Pu=7561ì¼ ë•Œ)
            if (tw === 9 && tf === 10 && Math.abs(Pu - 7561) < 1) {
                console.log('=== Auto Find Section ê³„ì‚° ê²°ê³¼ (tw=9, tf=10, Pu=7561) ===');
                console.log(`area: ${area.toFixed(2)}`);
                console.log(`Ix: ${Ix.toFixed(2)}, Iy: ${Iy.toFixed(2)}`);
                console.log(`ix: ${ix.toFixed(2)}, iy: ${iy.toFixed(2)}`);
                console.log(`lambda: ${lambda.toFixed(4)}`);
                console.log(`Fe1: ${Fe1.toFixed(2)}, Fe2: ${Fe2.toFixed(2)}, Fe: ${Fe.toFixed(2)}`);
                console.log(`Fcr: ${Fcr.toFixed(2)}`);
                console.log(`phi_Pn: ${phi_Pn.toFixed(2)}`);
                console.log(`Mpx: ${Mpx.toFixed(4)}, Mpy: ${Mpy.toFixed(4)}`);
                console.log(`phi_Mnx: ${phi_Mnx.toFixed(4)}, phi_Mny: ${phi_Mny.toFixed(4)}`);
                console.log(`ratio_comp: ${ratio_comp.toFixed(6)}`);
                console.log(`ratio_bendX: ${ratio_bendX.toFixed(6)}, ratio_bendY: ${ratio_bendY.toFixed(6)}`);
                console.log(`P-M-M: ${ratio_pmm.toFixed(6)}`);
                console.log(`Lx: ${Lx}, Ly: ${Ly}, Kx: ${Kx}, Ky: ${Ky}, Kz: ${Kz}`);
                console.log(`Fy: ${Fy}, E: ${E}, nu: ${nu}`);
            }

            // Ï†Pn < Puì¸ ê²½ìš° NG ì²´í¬
            const isCompressiveNG = phi_Pn < Pu; // Ï†Pn < Puì´ë©´ NG
            
            return { phi_Pn, area, ratio_pmm, tw, tf, lcf, lcfr, isSlenderFlange, isCompressiveNG };
        }

        // Auto Find Section: ìµœì  tw, tf ì¡°í•© ì°¾ê¸° (íŠ¹ì • H, B ì¡°í•©ì— ëŒ€í•´)
        function findOptimalSection(Pu, Mux, Muy, Fy, E, nu, Kx, Ky, Kz, Lx, Ly, h1, h2, b1, b2) {
            let bestTw = null;
            let bestTf = null;
            let bestArea = Infinity;
            let bestPMM = 0;
            let bestDiff = Infinity; // 1.0ê³¼ì˜ ì°¨ì´
            let bestIsSlenderFlange = false;

            // ëª¨ë“  tw, tf ì¡°í•© ì‹œë„
            for (const tw of twRange) {
                for (const tf of tfRange) {
                    if (tf < tw) continue; // tf >= tw ì¡°ê±´

                    const result = calculateSection(tw, tf, Fy, E, nu, Kx, Ky, Kz, Lx, Ly, Pu, Mux, Muy, h1, h2, b1, b2);
                    
                    // Î»cf > Î»cfrì¸ ê²½ìš° ì œì™¸ (Slender flange)
                    if (result.isSlenderFlange) continue;
                    
                    // P-M-M â‰¤ 1.0ì„ ë§Œì¡±í•˜ëŠ” ìµœì†Œ ë‹¨ë©´ì  ë‹¨ë©´ ì°¾ê¸° (ratioëŠ” 1.0ê¹Œì§€ í—ˆìš©)
                    if (result.ratio_pmm > 0 && result.ratio_pmm <= 1.0) {
                        if (result.area < bestArea) {
                            bestArea = result.area;
                            bestTw = tw;
                            bestTf = tf;
                            bestPMM = result.ratio_pmm;
                            bestDiff = Math.abs(1.0 - result.ratio_pmm);
                            bestIsSlenderFlange = result.isSlenderFlange;
                        }
                    }
                }
            }

            // P-M-M â‰¤ 1.0ì„ ë§Œì¡±í•˜ëŠ” ë‹¨ë©´ì´ ì—†ìœ¼ë©´, P-M-Mê°€ ê°€ì¥ ì‘ì€ ë‹¨ë©´ ë°˜í™˜
            // ratioëŠ” 1.0ê¹Œì§€ í—ˆìš©í•˜ë¯€ë¡œ, 1.0ì„ ì´ˆê³¼í•˜ëŠ” ê²½ìš°ëŠ” ìµœì†Œ ratioë¥¼ ì„ íƒ (ë‹¨, Î»cf â‰¤ Î»cfrì´ê³  Ï†Pn â‰¥ Puì¸ ê²½ìš°ë§Œ)
            if (bestTw === null) {
                let minPMM = Infinity;
                for (const tw of twRange) {
                    for (const tf of tfRange) {
                        if (tf < tw) continue;
                        const result = calculateSection(tw, tf, Fy, E, nu, Kx, Ky, Kz, Lx, Ly, Pu, Mux, Muy, h1, h2, b1, b2);
                        
                        // Î»cf > Î»cfrì¸ ê²½ìš° ì œì™¸
                        if (result.isSlenderFlange) continue;
                        
                        // Ï†Pn < Puì¸ ê²½ìš° ì œì™¸ (NG)
                        if (result.isCompressiveNG) continue;
                        
                        if (result.ratio_pmm < minPMM) {
                            minPMM = result.ratio_pmm;
                            bestArea = result.area;
                            bestTw = tw;
                            bestTf = tf;
                            bestPMM = result.ratio_pmm;
                            bestIsSlenderFlange = result.isSlenderFlange;
                        }
                    }
                }
            }

            return { tw: bestTw, tf: bestTf, area: bestArea, ratioPMM: bestPMM, isSlenderFlange: bestIsSlenderFlange };
        }

        // ë‹¨ì¤‘ ê³„ì‚° (kg/m)
        function calculateUnitWeight(area) {
            return (area / 1000000) * steelDensity;
        }

        // ëª¨ë“  ê³„ì‚° ìˆ˜í–‰
        function calculateAll() {
            const Fy = parseFloat(document.getElementById('steelGrade').value) || 420;
            const E = 210000;
            const nu = 0.3;
            const Kx = parseFloat(document.getElementById('Kx').value) || 0.8;
            const Ky = parseFloat(document.getElementById('Ky').value) || 0.8;
            const Kz = parseFloat(document.getElementById('Kz').value) || 0.8;

            currentResults = [];
            const tbody = document.getElementById('resultTableBody');
            tbody.innerHTML = '';

            // columnData ë°°ì—´ì˜ ëª¨ë“  ê¸°ë‘¥ì— ëŒ€í•´ ê³„ì‚° (ê¸°ë³¸ ê¸¸ì´ íƒ€ì… 1 ì‚¬ìš©)
            if (columnData.length === 0) {
                alert('í•˜ì¤‘ ì…ë ¥ í…Œì´ë¸”ì— ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. Pu ê°’ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                return;
            }
            
            columnData.forEach(col => {
                if (col.pu > 0) {
                    try {
                        // ê¸°ë³¸ ê¸¸ì´ íƒ€ì… 1 ì‚¬ìš© (ê³„ì‚° í›„ ê²°ê³¼ í…Œì´ë¸”ì—ì„œ ë³€ê²½ ê°€ëŠ¥)
                        const lengths = getLengthsForType(1);
                        const Lx = lengths.Lx;
                        const Ly = lengths.Ly;
                        
                        // ë‘ ê°€ì§€ ì¡°í•© ëª¨ë‘ ê³„ì‚°
                        let bestResult = null;
                        let bestCombination = null;
                        
                        for (const comb of combinations) {
                            const optimal = findOptimalSection(
                                col.pu, col.mux, col.muy, Fy, E, nu, Kx, Ky, Kz, Lx, Ly,
                                comb.H1, comb.H2, comb.B1, comb.B2
                            );
                            
                            if (optimal && optimal.tw && optimal.tf) {
                                // ë” ì‘ì€ ë‹¨ë©´ì ì„ ì„ íƒ
                                if (!bestResult || optimal.area < bestResult.area) {
                                    bestResult = optimal;
                                    bestCombination = comb;
                                }
                            }
                        }
                        
                        if (bestResult && bestResult.tw && bestResult.tf) {
                            // ìµœì¢… ê³„ì‚° ê²°ê³¼ (ì¬ê³„ì‚°ì„ ìœ„í•´)
                            const calcResult = calculateSection(
                                bestResult.tw, bestResult.tf, Fy, E, nu, Kx, Ky, Kz, Lx, Ly, 
                                col.pu, col.mux, col.muy,
                                bestCombination.H1, bestCombination.H2, bestCombination.B1, bestCombination.B2
                            );
                            
                            const unitWeight = calculateUnitWeight(bestResult.area);

                            // ê²°ê³¼ ê°ì²´ ìƒì„±
                            currentResults.push({
                                no: col.no,
                                name: col.name || `KC${col.no}`,
                                pu: col.pu,
                                mux: col.mux,
                                muy: col.muy,
                                pmm: bestResult.ratioPMM || calcResult.ratio_pmm || 0,
                                steelGrade: `SM${Fy}`,
                                combination: bestCombination.name,
                                kx: Kx,
                                lx: Lx / 1000, // mm to m
                                ly: Ly / 1000, // mm to m
                                h: bestCombination.H1,
                                b: bestCombination.B1,
                                tw: bestResult.tw,
                                tf: bestResult.tf,
                                area: bestResult.area,
                                unitWeight: unitWeight,
                                Fy: Fy,
                                E: E,
                                nu: nu,
                                Ky: Ky,
                                Kz: Kz,
                                isSlenderFlange: bestResult.isSlenderFlange || calcResult.isSlenderFlange,
                                lcf: calcResult.lcf,
                                lcfr: calcResult.lcfr,
                                isCompressiveNG: calcResult.isCompressiveNG,
                                phi_Pn: calcResult.phi_Pn,
                                H1: bestCombination.H1,
                                H2: bestCombination.H2,
                                B1: bestCombination.B1,
                                B2: bestCombination.B2
                            });
                            
                            console.log(`ê¸°ë‘¥ ${col.name || col.no}: ì¡°í•©=${bestCombination.name}, Pu=${col.pu}, tw=${bestResult.tw}, tf=${bestResult.tf}, P-M-M=${bestResult.ratioPMM?.toFixed(3)}, Area=${bestResult.area?.toFixed(2)}`);
                        } else {
                            console.error(`ê¸°ë‘¥ ${col.name || col.no}: ë‘ ì¡°í•© ëª¨ë‘ì—ì„œ ìµœì  ë‹¨ë©´ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
                        }
                    } catch (error) {
                        console.error(`ê¸°ë‘¥ ${col.name || col.no} ê³„ì‚° ì˜¤ë¥˜:`, error);
                    }
                }
            });

            // ê²°ê³¼ í…Œì´ë¸”ì— í‘œì‹œ
            if (currentResults.length > 0) {
                renderResults();
                console.log(`ê³„ì‚° ì™„ë£Œ: ${currentResults.length}ê°œ ê²°ê³¼ ìƒì„±ë¨`);
            } else {
                tbody.innerHTML = '<tr><td colspan="13" style="text-align: center; padding: 30px; color: #999;">Pu ê°’ì„ ì…ë ¥í•œ í•˜ì¤‘ì´ ì—†ìŠµë‹ˆë‹¤.</td></tr>';
                console.warn('ê³„ì‚° ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤. Pu ê°’ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
            }
        }

        // ê²°ê³¼ í…Œì´ë¸” ë Œë”ë§
        function renderResults() {
            const tbody = document.getElementById('resultTableBody');
            tbody.innerHTML = '';
            
            currentResults.forEach(result => {
                const row = document.createElement('tr');
                row.setAttribute('data-no', result.no);
                
                // ê²½ê³  ë©”ì‹œì§€ê°€ ìˆëŠ” ê²½ìš°
                if (result.warning) {
                    row.innerHTML = `
                        <td colspan="13" style="text-align: center; padding: 20px; color: #e53e3e; font-weight: 600; background: #fed7d7; border-radius: 4px;">
                            ${result.name}: ${result.warning} (Î»cf = ${result.lcf?.toFixed(2) || 'N/A'} > Î»cfr = ${result.lcfr?.toFixed(2) || 'N/A'})
                        </td>
                    `;
                    row.style.backgroundColor = '#fed7d7';
                } else {
                    // Î»cf > Î»cfr ê²½ê³  í‘œì‹œ
                    const slenderWarning = result.isSlenderFlange ? 
                        `<div style="color: #e53e3e; font-size: 11px; margin-top: 4px; font-weight: 600;">âš  Slender check needed</div>` : '';
                    
                    // Ï†Pn < Pu ê²½ê³  í‘œì‹œ (NG)
                    const compressiveWarning = result.isCompressiveNG ? 
                        `<div style="color: #e53e3e; font-size: 11px; margin-top: 4px; font-weight: 600;">âš  Compressive NG (Ï†Pn < Pu)</div>` : '';
                    
                    const warningText = slenderWarning + compressiveWarning;
                    
                    row.innerHTML = `
                        <td style="text-align: center; font-weight: 600;">${result.no}</td>
                        <td style="font-weight: 600; color: #667eea;">${result.name}${warningText}</td>
                        <td style="text-align: right;">${result.pu.toFixed(1)}</td>
                        <td class="pmm-cell" style="text-align: right; ${result.pmm > 1.0 ? 'color: #e53e3e; font-weight: 600;' : 'color: #38a169;'}">${result.pmm > 0 ? result.pmm.toFixed(3) : '-'}</td>
                        <td style="text-align: center;">${result.steelGrade}</td>
                        <td style="text-align: center; font-weight: 600; color: #667eea;">${result.combination || '-'}</td>
                        <td style="text-align: center;">${result.kx.toFixed(1)}</td>
                        <td style="text-align: right;">${result.lx.toFixed(1)}</td>
                        <td style="text-align: center;">${result.h}</td>
                        <td style="text-align: center;">${result.b}</td>
                        <td style="text-align: center;">
                            <input type="number" id="tw_${result.no}" value="${result.tw || ''}" min="8" max="16" step="1" 
                                   style="width: 60px; text-align: center; font-weight: 600; color: #667eea; border: 1px solid #cbd5e0; border-radius: 4px; padding: 4px;"
                                   onchange="recalculateRow(${result.no})">
                        </td>
                        <td style="text-align: center;">
                            <input type="number" id="tf_${result.no}" value="${result.tf || ''}" min="10" max="20" step="1"
                                   style="width: 60px; text-align: center; font-weight: 600; color: #667eea; border: 1px solid #cbd5e0; border-radius: 4px; padding: 4px;"
                                   onchange="recalculateRow(${result.no})">
                        </td>
                        <td class="area-cell" style="text-align: right;">${result.area ? result.area.toFixed(2) : '-'}</td>
                        <td class="weight-cell" style="text-align: right;">${result.unitWeight ? result.unitWeight.toFixed(4) : '-'}</td>
                    `;
                }
                tbody.appendChild(row);
            });
        }

        // íŠ¹ì • í–‰ ì¬ê³„ì‚° (tw, tf ë³€ê²½ ì‹œ)
        function recalculateRow(no) {
            const result = currentResults.find(r => r.no === no);
            if (!result) return;

            const tw = parseFloat(document.getElementById(`tw_${no}`).value);
            const tf = parseFloat(document.getElementById(`tf_${no}`).value);

            if (!tw || !tf || tf < tw) {
                alert(`ê¸°ë‘¥ ${result.name}: tfëŠ” twë³´ë‹¤ í¬ê±°ë‚˜ ê°™ì•„ì•¼ í•©ë‹ˆë‹¤.`);
                // ì›ë˜ ê°’ìœ¼ë¡œ ë³µì›
                document.getElementById(`tw_${no}`).value = result.tw;
                document.getElementById(`tf_${no}`).value = result.tf;
                return;
            }

            try {
                // ì¬ê³„ì‚° (ê¸°ì¡´ ì¡°í•© ë° ê¸¸ì´ ì‚¬ìš©)
                const calcResult = calculateSection(
                    tw, tf, result.Fy, result.E, result.nu, result.kx, result.Ky, result.Kz, 
                    result.lx * 1000, result.ly * 1000, result.pu, result.mux, result.muy,
                    result.H1, result.H2, result.B1, result.B2
                );
                const unitWeight = calculateUnitWeight(calcResult.area);
                
                // Î»cf > Î»cfr ì²´í¬
                const lcfr = 0.56 * Math.sqrt(result.E / result.Fy);
                const lcf = result.B2 / (2 * tf);
                const isSlenderFlange = lcf > lcfr;
                
                // Ï†Pn < Pu ì²´í¬ (NG)
                const isCompressiveNG = calcResult.phi_Pn < result.pu;

                // ê²°ê³¼ ì—…ë°ì´íŠ¸
                result.tw = tw;
                result.tf = tf;
                result.pmm = calcResult.ratio_pmm || 0;
                result.area = calcResult.area;
                result.unitWeight = unitWeight;
                result.isSlenderFlange = isSlenderFlange;
                result.lcf = lcf;
                result.lcfr = lcfr;
                result.isCompressiveNG = isCompressiveNG;
                result.phi_Pn = calcResult.phi_Pn;

                // í…Œì´ë¸” ì…€ ì—…ë°ì´íŠ¸
                const row = document.querySelector(`tr[data-no="${no}"]`);
                if (row) {
                    // ê¸°ë‘¥ëª… ì…€ì— ê²½ê³  ë©”ì‹œì§€ ì¶”ê°€/ì œê±°
                    const nameCell = row.querySelector('td:nth-child(2)');
                    if (nameCell) {
                        const baseName = result.name.split('âš ')[0].trim();
                        let warningHTML = '';
                        if (isSlenderFlange) {
                            warningHTML += `<div style="color: #e53e3e; font-size: 11px; margin-top: 4px; font-weight: 600;">âš  Slender check needed</div>`;
                        }
                        if (isCompressiveNG) {
                            warningHTML += `<div style="color: #e53e3e; font-size: 11px; margin-top: 4px; font-weight: 600;">âš  Compressive NG (Ï†Pn < Pu)</div>`;
                        }
                        nameCell.innerHTML = baseName + warningHTML;
                    }
                    
                    const pmmCell = row.querySelector('.pmm-cell');
                    const areaCell = row.querySelector('.area-cell');
                    const weightCell = row.querySelector('.weight-cell');

                    if (pmmCell) {
                        pmmCell.textContent = result.pmm > 0 ? result.pmm.toFixed(3) : '-';
                        pmmCell.style.color = result.pmm > 1.0 ? '#e53e3e' : '#38a169';
                        pmmCell.style.fontWeight = result.pmm > 1.0 ? '600' : 'normal';
                    }
                    if (areaCell) {
                        areaCell.textContent = result.area ? result.area.toFixed(2) : '-';
                    }
                    if (weightCell) {
                        weightCell.textContent = result.unitWeight ? result.unitWeight.toFixed(4) : '-';
                    }
                }

                console.log(`ê¸°ë‘¥ ${result.name}: tw=${tw}, tf=${tf}ë¡œ ì¬ê³„ì‚° - P-M-M=${result.pmm.toFixed(3)}, Area=${result.area.toFixed(2)}`);
            } catch (error) {
                console.error(`ê¸°ë‘¥ ${result.name} ì¬ê³„ì‚° ì˜¤ë¥˜:`, error);
                alert(`ì¬ê³„ì‚° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`);
            }
        }

        // BOQ ìƒì„± í•¨ìˆ˜
        function generateBOQ() {
            if (currentResults.length === 0) {
                alert('ë¨¼ì € ê³„ì‚°ì„ ì‹¤í–‰í•´ì£¼ì„¸ìš”.');
                return;
            }

            const boqSection = document.getElementById('boqSection');
            const boqTableBody = document.getElementById('boqTableBody');
            boqTableBody.innerHTML = '';

            let totalWeight = 0;
            let totalArea = 0;
            let totalCount = 0;

            // ê¸°ë‘¥ë³„ë¡œ ê·¸ë£¹í™”í•˜ì—¬ ë™ì¼ ê·œê²© í•©ì‚° (ê¸¸ì´ íƒ€ì…ë³„ë¡œë„ êµ¬ë¶„)
            const groupedResults = {};
            currentResults.forEach(result => {
                if (!result.tw || !result.tf) return; // ìœ íš¨í•˜ì§€ ì•Šì€ ê²°ê³¼ ì œì™¸
                
                // ê¸¸ì´ íƒ€ì…ë„ í‚¤ì— í¬í•¨í•˜ì—¬ ê¸¸ì´ íƒ€ì…ë³„ë¡œ êµ¬ë¶„
                const key = `${result.h}-${result.b}-${result.tw}-${result.tf}-${result.steelGrade}-${result.lengthType || 1}`;
                if (!groupedResults[key]) {
                    groupedResults[key] = {
                        combination: result.combination,
                        h: result.h,
                        b: result.b,
                        tw: result.tw,
                        tf: result.tf,
                        area: result.area,
                        unitWeight: result.unitWeight,
                        length: result.lx,
                        lengthType: result.lengthType || 1,
                        steelGrade: result.steelGrade,
                        count: 0,
                        names: []
                    };
                }
                groupedResults[key].count++;
                groupedResults[key].names.push(result.name);
            });

            // BOQ í…Œì´ë¸” ìƒì„±
            let rowNo = 1;
            Object.keys(groupedResults).forEach(key => {
                const item = groupedResults[key];
                const totalWeightItem = item.unitWeight * item.length * item.count;
                totalWeight += totalWeightItem;
                totalArea += item.area * item.count;
                totalCount += item.count;

                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${rowNo++}</td>
                    <td style="text-align: left; padding-left: 10px;">${item.names.join(', ')}</td>
                    <td>${item.combination}</td>
                    <td>H${item.h}Ã—B${item.b}</td>
                    <td>${item.h}</td>
                    <td>${item.b}</td>
                    <td>${item.tw}</td>
                    <td>${item.tf}</td>
                    <td style="text-align: right;">${item.area.toFixed(2)}</td>
                    <td style="text-align: right;">${item.unitWeight.toFixed(4)}</td>
                    <td style="text-align: right;">${item.length.toFixed(2)}<br><span style="font-size: 10px; color: #666;">(íƒ€ì…${item.lengthType})</span></td>
                    <td>${item.count}</td>
                    <td style="text-align: right; font-weight: 600;">${totalWeightItem.toFixed(2)}</td>
                    <td>${item.steelGrade}</td>
                `;
                boqTableBody.appendChild(row);
            });

            // í•©ê³„ í–‰ ì¶”ê°€
            const totalRow = document.createElement('tr');
            totalRow.className = 'total-row';
            totalRow.innerHTML = `
                <td colspan="11" style="text-align: right; font-weight: 600;">í•©ê³„</td>
                <td style="font-weight: 600;">${totalCount}</td>
                <td style="text-align: right; font-weight: 600;">${totalWeight.toFixed(2)}</td>
                <td></td>
            `;
            boqTableBody.appendChild(totalRow);

            // BOQ ì„¹ì…˜ í‘œì‹œ
            boqSection.classList.add('show');
            
            // BOQ ì„¹ì…˜ìœ¼ë¡œ ìŠ¤í¬ë¡¤
            boqSection.scrollIntoView({ behavior: 'smooth', block: 'start' });

            console.log(`BOQ ìƒì„± ì™„ë£Œ: ${totalCount}ê°œ ê¸°ë‘¥, ì´ ì¤‘ëŸ‰: ${totalWeight.toFixed(2)} kg`);
        }

        // BOQ ì¸ì‡„ í•¨ìˆ˜
        function printBOQ() {
            const boqSection = document.getElementById('boqSection');
            if (!boqSection.classList.contains('show')) {
                alert('ë¨¼ì € BOQë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”.');
                return;
            }

            // ì¸ì‡„ìš© ìŠ¤íƒ€ì¼ ì¶”ê°€
            const printStyle = `
                <style>
                    @media print {
                        body * {
                            visibility: hidden;
                        }
                        .boq-section, .boq-section * {
                            visibility: visible;
                        }
                        .boq-section {
                            position: absolute;
                            left: 0;
                            top: 0;
                            width: 100%;
                        }
                        .section-title {
                            font-size: 20px;
                            margin-bottom: 20px;
                        }
                        .boq-table {
                            font-size: 10px;
                        }
                        .boq-table th,
                        .boq-table td {
                            padding: 6px;
                        }
                        button {
                            display: none;
                        }
                    }
                </style>
            `;
            
            const printWindow = window.open('', '_blank');
            printWindow.document.write(`
                <html>
                    <head>
                        <title>BOQ - ê³µì‚¬ ìˆ˜ëŸ‰ ì‚°ì¶œì„œ</title>
                        ${printStyle}
                        <style>
                            body {
                                font-family: 'Segoe UI', Arial, sans-serif;
                                padding: 20px;
                            }
                            .boq-table {
                                width: 100%;
                                border-collapse: collapse;
                                font-size: 11px;
                            }
                            .boq-table th,
                            .boq-table td {
                                padding: 8px;
                                text-align: center;
                                border: 1px solid #333;
                            }
                            .boq-table th {
                                background: #2d5a87;
                                color: white;
                                font-weight: 600;
                            }
                            .boq-table .total-row {
                                background: #e8f4f8;
                                font-weight: 600;
                            }
                            h1 {
                                text-align: center;
                                margin-bottom: 20px;
                            }
                        </style>
                    </head>
                    <body>
                        <h1>BOQ (Bill of Quantities) - ê³µì‚¬ ìˆ˜ëŸ‰ ì‚°ì¶œì„œ</h1>
                        ${boqSection.innerHTML}
                    </body>
                </html>
            `);
            printWindow.document.close();
            printWindow.print();
        }

        // BOQ CSV ë‹¤ìš´ë¡œë“œ í•¨ìˆ˜
        function exportBOQToCSV() {
            if (currentResults.length === 0) {
                alert('ë¨¼ì € ê³„ì‚°ì„ ì‹¤í–‰í•´ì£¼ì„¸ìš”.');
                return;
            }

            // ê¸°ë‘¥ë³„ë¡œ ê·¸ë£¹í™” (ê¸¸ì´ íƒ€ì…ë³„ë¡œë„ êµ¬ë¶„)
            const groupedResults = {};
            currentResults.forEach(result => {
                if (!result.tw || !result.tf) return;
                
                const key = `${result.h}-${result.b}-${result.tw}-${result.tf}-${result.steelGrade}-${result.lengthType || 1}`;
                if (!groupedResults[key]) {
                    groupedResults[key] = {
                        combination: result.combination,
                        h: result.h,
                        b: result.b,
                        tw: result.tw,
                        tf: result.tf,
                        area: result.area,
                        unitWeight: result.unitWeight,
                        length: result.lx,
                        lengthType: result.lengthType || 1,
                        steelGrade: result.steelGrade,
                        count: 0,
                        names: []
                    };
                }
                groupedResults[key].count++;
                groupedResults[key].names.push(result.name);
            });

            // CSV í—¤ë”
            let csv = 'No.,ê¸°ë‘¥ëª…,ì¡°í•©,ê·œê²©,H(mm),B(mm),tw(mm),tf(mm),ë‹¨ë©´ì (mmÂ²),ë‹¨ì¤‘(kg/m),ê¸¸ì´(m),ê¸¸ì´íƒ€ì…,ê°œìˆ˜,ì´ì¤‘ëŸ‰(kg),ê°•ì¢…\n';

            // CSV ë°ì´í„°
            let rowNo = 1;
            let totalWeight = 0;
            let totalCount = 0;

            Object.keys(groupedResults).forEach(key => {
                const item = groupedResults[key];
                const totalWeightItem = item.unitWeight * item.length * item.count;
                totalWeight += totalWeightItem;
                totalCount += item.count;

                csv += `${rowNo++},${item.names.join(';')},${item.combination},H${item.h}Ã—B${item.b},${item.h},${item.b},${item.tw},${item.tf},${item.area.toFixed(2)},${item.unitWeight.toFixed(4)},${item.length.toFixed(2)},íƒ€ì…${item.lengthType},${item.count},${totalWeightItem.toFixed(2)},${item.steelGrade}\n`;
            });

            // í•©ê³„ í–‰
            csv += `í•©ê³„,,,,,,,,,,${totalCount},${totalWeight.toFixed(2)},\n`;

            // BOM ì¶”ê°€ (í•œê¸€ ê¹¨ì§ ë°©ì§€)
            const bom = '\uFEFF';
            const blob = new Blob([bom + csv], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', `BOQ_${new Date().toISOString().split('T')[0]}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }

        // ê³„ì‚°ì„œ ì¶œë ¥ í•¨ìˆ˜
        function printCalculationSheet() {
            if (currentResults.length === 0) {
                alert('ë¨¼ì € ê³„ì‚°ì„ ì‹¤í–‰í•´ì£¼ì„¸ìš”.');
                return;
            }

            // ì²« ë²ˆì§¸ ê¸°ë‘¥ì˜ ë°ì´í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ ê³„ì‚°ì„œ ìƒì„±
            const firstResult = currentResults[0];
            const col = columnData.find(c => c.no === firstResult.no);
            
            if (!col) {
                alert('ê¸°ë‘¥ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            // ì¼ë°˜ H-beamì˜ ê²½ìš° ê³„ì‚°ì„œ ì¶œë ¥ ë¶ˆê°€ (Cross H Columnë§Œ ì§€ì›)
            if (firstResult.sectionType === 'H-beam') {
                alert('ì¼ë°˜ H-beamì˜ ê³„ì‚°ì„œ ì¶œë ¥ì€ í˜„ì¬ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Cross H Columnë§Œ ê³„ì‚°ì„œë¥¼ ì¶œë ¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                return;
            }

            // ì…ë ¥ ë°ì´í„° ì €ì¥ (Main Calculator í˜•ì‹ê³¼ í˜¸í™˜)
            const inputData = {
                // Section Dimensions
                H1: firstResult.H1,
                B1: firstResult.B1,
                tw1: firstResult.tw,
                tf1: firstResult.tf,
                r1: 0, // Built-up ë¶€ì¬
                H2: firstResult.H2,
                B2: firstResult.B2,
                tw2: firstResult.tw,
                tf2: firstResult.tf,
                r2: 0, // Built-up ë¶€ì¬
                // Material
                steelGrade: `SM${parseFloat(document.getElementById('steelGrade').value) || 420}`,
                Fy: parseFloat(document.getElementById('steelGrade').value) || 420,
                E: 210000,
                nu: 0.3,
                // Length & Buckling
                Lx: parseFloat(document.getElementById('Lx').value) || 4.5,
                Ly: parseFloat(document.getElementById('Ly').value) || 4.5,
                Lb: parseFloat(document.getElementById('Lx').value) || 4.5,
                Kx: parseFloat(document.getElementById('Kx').value) || 0.8,
                Ky: parseFloat(document.getElementById('Ky').value) || 0.8,
                Kz: parseFloat(document.getElementById('Kz').value) || 0.8,
                Cb: 1.0,
                // Design Load
                Pu: col.pu,
                Mux: col.mux,
                Muy: col.muy,
                Vux: 0,
                Vuy: 0,
                // Name
                name: col.name || 'Auto Find Section'
            };

            // localStorageì— ì €ì¥
            localStorage.setItem('kcolInputData', JSON.stringify(inputData));

            // ê³„ì‚°ì„œ í˜ì´ì§€ë¥¼ ìƒˆ ì°½ì—ì„œ ì—´ê¸°
            const calcWindow = window.open('Cross-H-Column-Calculation-Data1.html', '_blank');
            
            if (calcWindow) {
                console.log('ê³„ì‚°ì„œ ì¶œë ¥: ì²« ë²ˆì§¸ ê¸°ë‘¥ ë°ì´í„° ì‚¬ìš©');
                console.log('ê¸°ë‘¥ëª…:', col.name);
                console.log('Pu:', col.pu, 'Mux:', col.mux, 'Muy:', col.muy);
                console.log('tw:', firstResult.tw, 'tf:', firstResult.tf);
            }
        }
    </script>
</body>
</html>