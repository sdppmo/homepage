<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Castellated Beam Design Calculator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .calculator-wrapper {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #1e3a5f, #2d5a87);
            color: white;
            padding: 20px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .header a {
            color: rgba(255,255,255,0.9);
            text-decoration: none;
            font-size: 14px;
            padding: 8px 16px;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            transition: all 0.3s;
        }

        .header a:hover {
            background: rgba(255,255,255,0.1);
        }

        .header .header-links {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .type-badge {
            display: inline-block;
            padding: 4px 12px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            font-size: 12px;
            margin-left: 10px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0;
            min-height: 600px;
        }

        .left-section, .right-section {
            padding: 25px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        .left-section {
            background: #f8fafc;
            border-right: 1px solid #e2e8f0;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px 20px;
            align-content: start;
        }

        .right-section {
            background: #ffffff;
        }

        .section-title {
            font-size: 18px;
            font-weight: 700;
            color: #1e3a5f;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #3b82f6;
            grid-column: 1 / -1;
        }

        .input-group {
            margin-bottom: 0;
        }
        
        .input-group.full-width {
            grid-column: 1 / -1;
        }

        .input-group label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: #475569;
            margin-bottom: 6px;
        }

        .input-field {
            width: 100%;
            padding: 10px;
            border: 2px solid #cbd5e1;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .input-field:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .calc-btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
            margin-top: 20px;
        }

        .calc-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.5);
        }

        .results-container {
            display: none;
        }

        .results-container.active {
            display: block;
        }

        .result-section {
            margin-bottom: 25px;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
        }

        .result-section-title {
            font-size: 16px;
            font-weight: 700;
            color: #1e3a5f;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #3b82f6;
        }

        .result-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .result-table th,
        .result-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }

        .result-table th {
            background: #f1f5f9;
            font-weight: 600;
            color: #475569;
        }

        .result-value {
            font-weight: 600;
            color: #1e3a5f;
            text-align: right;
        }

        .status-ok {
            color: #10b981;
            font-weight: 700;
        }

        .status-ng {
            color: #ef4444;
            font-weight: 700;
        }

        .info-box {
            background: #eff6ff;
            border: 1px solid #bfdbfe;
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 0;
            font-size: 13px;
            color: #1e40af;
            line-height: 1.6;
        }

        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .left-section {
                border-right: none;
                border-bottom: 1px solid #e2e8f0;
            }
        }
    </style>
</head>
<body>
    <div class="calculator-wrapper">
        <div class="header">
            <div>
                <h1>Castellated Beam Design Calculator
                    <span class="type-badge" id="typeBadge">Loading...</span>
                </h1>
            </div>
            <div class="header-links">
                <a href="/">← 홈으로</a>
                <a href="?type=with-slab">With top-slab 바로가기</a>
            </div>
        </div>

        <div class="main-content">
            <div class="left-section">
                <div class="section-title">입력 조건</div>
                
                <div class="info-box input-group full-width" id="typeInfo">
                    계산 방식을 확인 중...
                </div>

                <div class="input-group">
                    <label for="beamSpan">보 스팬 (L, m)</label>
                    <input type="number" id="beamSpan" class="input-field" value="13.5" step="0.1" min="0.1">
                </div>

                <div class="input-group">
                    <label for="loadWidth">하중 폭 (B, m)</label>
                    <input type="number" id="loadWidth" class="input-field" value="3.0" step="0.1" min="0.1">
                </div>

                <div class="input-group">
                    <label for="liveLoad">활하중 (qL, kN/m²)</label>
                    <input type="number" id="liveLoad" class="input-field" value="3.5" step="0.1" min="0">
                </div>

                <div class="input-group">
                    <label for="deadLoad">고정하중 (qD, kN/m²) - Super imposed Dead Load</label>
                    <input type="number" id="deadLoad" class="input-field" value="0.8" step="0.1" min="0">
                </div>

                <div class="input-group">
                    <label for="constructionLoad">가설하중 (qConst, kN/m²) - 시공하중</label>
                    <input type="number" id="constructionLoad" class="input-field" value="1.0" step="0.1" min="0">
                </div>

                <div class="input-group">
                    <label for="selfWeight">보 자중 (self_w, kN/m²) - 자동계산</label>
                    <input type="number" id="selfWeight" class="input-field" value="1.0" step="0.001" min="0" readonly style="background: #f1f5f9;">
                </div>

                <div class="input-group">
                    <label for="slabThickness">슬래브 두께 (ts, mm)</label>
                    <input type="number" id="slabThickness" class="input-field" value="135" step="1" min="0">
                </div>

                <div class="input-group">
                    <label for="steelGrade">강종</label>
                    <select id="steelGrade" class="input-field">
                        <option value="SM355" selected>SM355 (Fy = 355 MPa)</option>
                        <option value="SM420">SM420 (Fy = 420 MPa)</option>
                        <option value="SS275">SS275 (Fy = 275 MPa)</option>
                    </select>
                </div>

                <div class="input-group">
                    <label for="slabWeight">슬래브 자중 (kN/m²) - 자동계산</label>
                    <input type="number" id="slabWeight" class="input-field" value="0" step="0.001" min="0" readonly style="background: #f1f5f9;">
                </div>

                <div class="section-title" style="margin-top: 20px;">원단면 치수 (H형강)</div>

                <div class="input-group full-width">
                    <label for="ksSection">KS 단면 선택</label>
                    <select id="ksSection" class="input-field" style="height: 40px;">
                        <option value="">직접 입력</option>
                    </select>
                    <div style="font-size: 11px; color: #94a3b8; margin-top: 4px;">※ KS 단면 선택 시 아래 값이 자동 입력됩니다</div>
                </div>

                <div class="input-group">
                    <label for="beamDepth">보 높이 (dc, mm) - dc = 원치수 × 1.5 (자동계산)</label>
                    <input type="number" id="beamDepth" class="input-field" value="900" step="10" min="100">
                    <div style="font-size: 11px; color: #94a3b8; margin-top: 4px;">※ KS 단면 선택 시 자동 계산됩니다 (예: H600 → 900mm)</div>
                </div>

                <div class="input-group">
                    <label for="flangeWidth">플랜지 폭 (bf, mm)</label>
                    <input type="number" id="flangeWidth" class="input-field" value="200" step="1" min="0">
                </div>

                <div class="input-group">
                    <label for="flangeThickness">플랜지 두께 (tf, mm)</label>
                    <input type="number" id="flangeThickness" class="input-field" value="17" step="1" min="0">
                </div>

                <div class="input-group">
                    <label for="webThickness">웹 두께 (tw, mm)</label>
                    <input type="number" id="webThickness" class="input-field" value="11" step="1" min="0">
                </div>

                <div class="input-group">
                    <label for="filletRadius">필렛 반경 (r, mm)</label>
                    <input type="number" id="filletRadius" class="input-field" value="18" step="1" min="0">
                    <div style="font-size: 11px; color: #94a3b8; margin-top: 4px;">※ KS 단면 선택 시 자동 입력됩니다</div>
                </div>

                <div class="section-title" style="margin-top: 20px;">개구부 정보</div>

                <div class="input-group">
                    <label for="openingHeight">개구부 높이 (ho, m) - ho ≤ 0.6dc (자동계산)</label>
                    <input type="number" id="openingHeight" class="input-field" value="0.6" step="0.01" min="0.1" readonly style="background: #f1f5f9;">
                </div>

                <div class="input-group">
                    <label for="openingSpacing">개구부 간격 (p, m) - p = W_open + e (자동계산)</label>
                    <input type="number" id="openingSpacing" class="input-field" value="0.9" step="0.01" min="0.1" readonly style="background: #f1f5f9;">
                </div>

                <div class="input-group">
                    <label for="openingAngle">개구부 각도 (θ, deg)</label>
                    <input type="number" id="openingAngle" class="input-field" value="60" step="1" min="0" max="90">
                </div>

                <div class="input-group">
                    <label for="endPost">양단 End Post 길이 (m) - endPost = dc (자동계산)</label>
                    <input type="number" id="endPost" class="input-field" value="0.9" step="0.01" min="0" readonly style="background: #f1f5f9;">
                </div>

                <div class="input-group full-width">
                    <label for="openingWidth">웹포스트폭 (Web Post width : e, mm) = 두 개구부 사이 남는 웹 두께 방향 폭</label>
                    <input type="number" id="openingWidth" class="input-field" value="200" step="1" min="0">
                    <div id="openingWidthRange" style="font-size: 11px; color: #64748b; margin-top: 4px;">
                        최소값(H/2)= <span id="openingWidthMin">-</span>mm ~ 최대값(1.5*ho)= <span id="openingWidthMax">-</span>mm
                    </div>
                </div>

                <button class="calc-btn input-group full-width" onclick="calculateBeam()" style="grid-column: 1 / -1;">계산하기</button>
            </div>

            <div class="right-section">
                <div class="section-title">계산 결과</div>
                <div id="resultsContainer" class="results-container">
                    <div id="noResults" style="text-align: center; padding: 60px 20px; color: #94a3b8;">
                        <p style="font-size: 16px; margin-bottom: 10px;">계산 결과가 여기에 표시됩니다</p>
                        <p style="font-size: 12px;">좌측 입력값을 입력하고 "계산하기" 버튼을 클릭하세요</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Get type from URL parameter
        const urlParams = new URLSearchParams(window.location.search);
        const beamType = urlParams.get('type') || 'without-slab';

        // KS H-beam section database (H×B×tw×tf) - 직사각형 H형강
        // 단중(kg/m) 계산 함수
        function calculateUnitWeight(d, bf, tw, tf) {
            const hw = d - 2 * tf;
            const area = bf * tf * 2 + hw * tw; // mm²
            const unitWeight = (area / 1000000) * 7850; // kg/m (강재 밀도 7850 kg/m³)
            return unitWeight;
        }

        const ksSections = {
            'H150x75x5x7': { d: 150, bf: 75, tw: 5, tf: 7, r: 8 },
            'H198x99x4.5x7': { d: 198, bf: 99, tw: 4.5, tf: 7, r: 8 },
            'H200x100x5.5x8': { d: 200, bf: 100, tw: 5.5, tf: 8, r: 8 },
            'H250x125x6x9': { d: 250, bf: 125, tw: 6, tf: 9, r: 10 },
            'H294x200x8x12': { d: 294, bf: 200, tw: 8, tf: 12, r: 13 },
            'H298x149x6.5x9': { d: 298, bf: 149, tw: 6.5, tf: 9, r: 13 },
            'H300x150x6.5x9': { d: 300, bf: 150, tw: 6.5, tf: 9, r: 13 },
            'H346x174x6x9': { d: 346, bf: 174, tw: 6, tf: 9, r: 13 },
            'H350x175x7x11': { d: 350, bf: 175, tw: 7, tf: 11, r: 13 },
            'H340x250x9x14': { d: 340, bf: 250, tw: 9, tf: 14, r: 13 },
            'H390x300x10x16': { d: 390, bf: 300, tw: 10, tf: 16, r: 18 },
            'H396x199x7x11': { d: 396, bf: 199, tw: 7, tf: 11, r: 13 },
            'H400x200x8x13': { d: 400, bf: 200, tw: 8, tf: 13, r: 13 },
            'H446x199x8x12': { d: 446, bf: 199, tw: 8, tf: 12, r: 13 },
            'H450x200x9x14': { d: 450, bf: 200, tw: 9, tf: 14, r: 18 },
            'H482x300x11x15': { d: 482, bf: 300, tw: 11, tf: 15, r: 18 },
            'H488x300x11x16': { d: 488, bf: 300, tw: 11, tf: 16, r: 18 },
            'H496x199x9x14': { d: 496, bf: 199, tw: 9, tf: 14, r: 18 },
            'H500x200x10x16': { d: 500, bf: 200, tw: 10, tf: 16, r: 18 },
            'H506x201x11x19': { d: 506, bf: 201, tw: 11, tf: 19, r: 18 },
            'H582x300x12x17': { d: 582, bf: 300, tw: 12, tf: 17, r: 18 },
            'H588x300x12x18': { d: 588, bf: 300, tw: 12, tf: 18, r: 18 },
            'H594x302x14x23': { d: 594, bf: 302, tw: 14, tf: 23, r: 22 },
            'H596x199x10x15': { d: 596, bf: 199, tw: 10, tf: 15, r: 18 },
            'H600x200x11x17': { d: 600, bf: 200, tw: 11, tf: 17, r: 18 },
            'H606x201x12x20': { d: 606, bf: 201, tw: 12, tf: 20, r: 18 },
            'H692x300x13x20': { d: 692, bf: 300, tw: 13, tf: 20, r: 22 },
            'H700x300x13x24': { d: 700, bf: 300, tw: 13, tf: 24, r: 22 },
            'H792x300x14x22': { d: 792, bf: 300, tw: 14, tf: 22, r: 22 },
            'H800x300x14x26': { d: 800, bf: 300, tw: 14, tf: 26, r: 22 },
            'H890x299x15x23': { d: 890, bf: 299, tw: 15, tf: 23, r: 22 },
            'H900x300x16x28': { d: 900, bf: 300, tw: 16, tf: 28, r: 22 },
            'H912x302x18x34': { d: 912, bf: 302, tw: 18, tf: 34, r: 22 }
        };

        // 각 단면의 단중 계산 및 저장
        Object.keys(ksSections).forEach(key => {
            const section = ksSections[key];
            section.unitWeight = calculateUnitWeight(section.d, section.bf, section.tw, section.tf);
        });

        // KS 단면 옵션 생성 함수
        function populateKsSectionOptions() {
            try {
                const ksSectionSelect = document.getElementById('ksSection');
                if (!ksSectionSelect) {
                    console.log('[DEBUG] populateKsSectionOptions: ksSection select element not found');
                    return false;
                }
                
                if (typeof ksSections === 'undefined' || !ksSections) {
                    console.error('[ERROR] populateKsSectionOptions: ksSections is not defined');
                    return false;
                }
                
                const sectionsCount = Object.keys(ksSections).length;
                if (sectionsCount === 0) {
                    console.error('[ERROR] populateKsSectionOptions: ksSections is empty');
                    return false;
                }
                
                // 모든 옵션 제거 후 직접 입력 옵션만 다시 추가
                ksSectionSelect.innerHTML = '<option value="">직접 입력</option>';
                
                // 높이(d) 순으로 정렬
                const sortedKeys = Object.keys(ksSections).sort((a, b) => {
                    const dA = ksSections[a].d;
                    const dB = ksSections[b].d;
                    if (dA !== dB) return dA - dB;
                    // 높이가 같으면 폭(bf) 순으로 정렬
                    return ksSections[a].bf - ksSections[b].bf;
                });
                
                // 기본값 설정 (H600x200x11x17)
                const defaultSection = 'H600x200x11x17';
                
                sortedKeys.forEach(key => {
                    try {
                        const section = ksSections[key];
                        if (!section) {
                            console.warn('[WARN] Section not found for key:', key);
                            return;
                        }
                        const option = document.createElement('option');
                        option.value = key;
                        
                        // 기본값으로 선택
                        if (key === defaultSection) {
                            option.selected = true;
                        }
                        
                        // 단면명 추출 (예: "H500x200x10x16" -> "H 500×200")
                        const match = key.match(/H(\d+)x(\d+)/);
                        if (match) {
                            // 단중이 있으면 함께 표시
                            if (section.unitWeight) {
                                option.textContent = `H ${match[1]}×${match[2]} (단중: ${section.unitWeight.toFixed(1)} kg/m)`;
                            } else {
                                option.textContent = `H ${match[1]}×${match[2]}`;
                            }
                        } else {
                            // 단중이 있으면 함께 표시
                            if (section.unitWeight) {
                                option.textContent = `${key} (단중: ${section.unitWeight.toFixed(1)} kg/m)`;
                            } else {
                                option.textContent = key;
                            }
                        }
                        
                        ksSectionSelect.appendChild(option);
                    } catch (err) {
                        console.error('[ERROR] Error creating option for key:', key, err);
                    }
                });
                
                // 기본값이 설정된 경우 관련 필드 자동 업데이트
                if (ksSections[defaultSection]) {
                    setTimeout(() => {
                        onKsSectionChange();
                    }, 100);
                }
                
                return true;
            } catch (error) {
                console.error('[ERROR] populateKsSectionOptions error:', error);
                return false;
            }
        }

        // KS 섹션 선택 시 자동 입력
        function onKsSectionChange() {
            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/f6b33b86-5eb3-41dd-83f7-9e0a0382507b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'castellated-beam-calculator.html:477',message:'onKsSectionChange called',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
            // #endregion
            
            try {
                const ksSectionSelect = document.getElementById('ksSection');
                if (!ksSectionSelect) {
                    // #region agent log
                    fetch('http://127.0.0.1:7242/ingest/f6b33b86-5eb3-41dd-83f7-9e0a0382507b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'castellated-beam-calculator.html:482',message:'ksSectionSelect is null',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
                    // #endregion
                    console.error('[ERROR] ksSection element not found');
                    return;
                }
                
                const selectedValue = ksSectionSelect.value;
                
                if (!selectedValue || selectedValue === '') {
                    // 직접 입력 모드
                    return;
                }
                
                const section = ksSections[selectedValue];
                if (!section) {
                    // #region agent log
                    fetch('http://127.0.0.1:7242/ingest/f6b33b86-5eb3-41dd-83f7-9e0a0382507b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'castellated-beam-calculator.html:495',message:'Section not found in ksSections',data:{selectedValue:selectedValue},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
                    // #endregion
                    console.error('[ERROR] Section not found:', selectedValue);
                    return;
                }
                
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/f6b33b86-5eb3-41dd-83f7-9e0a0382507b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'castellated-beam-calculator.html:500',message:'Setting section values',data:{section:section,selectedValue:selectedValue},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
                // #endregion
                
                // 치수 입력 (mm 단위) - null 체크 추가
                const flangeWidthEl = document.getElementById('flangeWidth');
                const flangeThicknessEl = document.getElementById('flangeThickness');
                const webThicknessEl = document.getElementById('webThickness');
                const beamDepthEl = document.getElementById('beamDepth');
                const filletRadiusEl = document.getElementById('filletRadius');
                
                if (!flangeWidthEl) {
                    // #region agent log
                    fetch('http://127.0.0.1:7242/ingest/f6b33b86-5eb3-41dd-83f7-9e0a0382507b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'castellated-beam-calculator.html:510',message:'flangeWidth element is null',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
                    // #endregion
                    console.error('[ERROR] flangeWidth element not found');
                    return;
                }
                if (!flangeThicknessEl) {
                    // #region agent log
                    fetch('http://127.0.0.1:7242/ingest/f6b33b86-5eb3-41dd-83f7-9e0a0382507b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'castellated-beam-calculator.html:516',message:'flangeThickness element is null',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
                    // #endregion
                    console.error('[ERROR] flangeThickness element not found');
                    return;
                }
                if (!webThicknessEl) {
                    // #region agent log
                    fetch('http://127.0.0.1:7242/ingest/f6b33b86-5eb3-41dd-83f7-9e0a0382507b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'castellated-beam-calculator.html:522',message:'webThickness element is null',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
                    // #endregion
                    console.error('[ERROR] webThickness element not found');
                    return;
                }
                if (!beamDepthEl) {
                    // #region agent log
                    fetch('http://127.0.0.1:7242/ingest/f6b33b86-5eb3-41dd-83f7-9e0a0382507b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'castellated-beam-calculator.html:528',message:'beamDepth element is null',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
                    // #endregion
                    console.error('[ERROR] beamDepth element not found');
                    return;
                }
                
                flangeWidthEl.value = section.bf;
                flangeThicknessEl.value = section.tf;
                webThicknessEl.value = section.tw;
                
                // 필렛 반경 설정
                if (filletRadiusEl && section.r) {
                    filletRadiusEl.value = section.r;
                }
                
                // 보 높이 입력 (원치수의 1.5배, mm 단위)
                // 예: H600 (600mm) → 600 × 1.5 = 900mm
                const beamDepthValue = Math.round(section.d * 1.5);
                beamDepthEl.value = beamDepthValue;
                
                // 보 자중 자동 계산
                setTimeout(updateSelfWeight, 50);
                
                // 개구부 높이 자동 계산 (ho ≤ 0.6dc)
                // dc는 mm 단위, ho는 m 단위로 표시
                const openingHeightEl = document.getElementById('openingHeight');
                if (openingHeightEl) {
                    const hoValue = (0.6 * beamDepthValue) / 1000;  // mm → m 변환
                    openingHeightEl.value = hoValue.toFixed(3);
                }
                
                // 개구부 간격은 updateOpeningSpacing()에서 자동 계산됨
                // (openingWidth가 먼저 설정되어야 함)
                setTimeout(updateOpeningSpacing, 100);
                
                // End Post 길이 자동 계산 (endPost = dc)
                // dc는 mm 단위, endPost는 m 단위로 표시
                const endPostEl = document.getElementById('endPost');
                if (endPostEl) {
                    const endPostValue = beamDepthValue / 1000;  // mm → m 변환
                    endPostEl.value = endPostValue.toFixed(3);
                }
                
                // 개구부 폭 범위 업데이트 (개구부 높이가 먼저 계산되어야 함)
                // updateOpeningWidth()는 beamDepth와 openingHeight 변경 시 자동 호출됨
                setTimeout(updateOpeningWidth, 50);
                
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/f6b33b86-5eb3-41dd-83f7-9e0a0382507b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'castellated-beam-calculator.html:540',message:'Values set successfully',data:{bf:section.bf,tf:section.tf,tw:section.tw,beamDepth:beamDepthValue},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
                // #endregion
            } catch (error) {
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/f6b33b86-5eb3-41dd-83f7-9e0a0382507b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'castellated-beam-calculator.html:544',message:'Error in onKsSectionChange',data:{error:error.message,stack:error.stack},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
                // #endregion
                console.error('[ERROR] onKsSectionChange error:', error);
                alert('단면 선택 중 오류가 발생했습니다: ' + error.message);
            }
        }

        // Update UI based on type
        function initializeType() {
            const typeBadge = document.getElementById('typeBadge');
            const typeInfo = document.getElementById('typeInfo');
            const headerH1 = document.querySelector('.header h1');

            if (beamType === 'with-slab') {
                typeBadge.textContent = 'with top-slab';
                typeInfo.innerHTML = '<strong>Castellated Beam with top-slab</strong><br>상부 슬래브가 있는 Castellated Beam 설계 계산기입니다.';
                if (headerH1) {
                    // h1의 텍스트 노드 찾기
                    for (let node of headerH1.childNodes) {
                        if (node.nodeType === 3) { // Text node
                            node.textContent = 'Castellated Beam Design Calculator ';
                            break;
                        }
                    }
                }
            } else {
                typeBadge.textContent = 'without top-slab';
                typeInfo.innerHTML = '<strong>Castellated Beam without top-slab</strong><br>상부 슬래브가 없는 Castellated Beam 설계 계산기입니다.';
                if (headerH1) {
                    // h1의 텍스트 노드 찾기
                    for (let node of headerH1.childNodes) {
                        if (node.nodeType === 3) { // Text node
                            node.textContent = 'Non Composite Castillated Beam Design Calculator ';
                            break;
                        }
                    }
                }
            }
        }

        // Format number with commas
        function formatNumber(num, decimals) {
            if (isNaN(num) || !isFinite(num)) return '-';
            return num.toFixed(decimals).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
        }

        // Get Fy from steel grade
        function getFy(grade) {
            const grades = {
                'SM355': 355,
                'SM420': 420,
                'SS275': 275
            };
            return grades[grade] || 355;
        }

        // Main calculation function
        function calculateBeam() {
            try {
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/f6b33b86-5eb3-41dd-83f7-9e0a0382507b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'castellated-beam-calculator.html:669',message:'calculateBeam 함수 시작',data:{},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
                // #endregion
                
                // Get input values
                const L = parseFloat(document.getElementById('beamSpan').value) || 0;
                const B = parseFloat(document.getElementById('loadWidth').value) || 0;
                const qL = parseFloat(document.getElementById('liveLoad').value) || 0;
                const qD = parseFloat(document.getElementById('deadLoad').value) || 0;
                const qConst = parseFloat(document.getElementById('constructionLoad').value) || 0;
                const self_w = parseFloat(document.getElementById('selfWeight').value) || 0;
                const slabWeight = parseFloat(document.getElementById('slabWeight').value) || 0;
                
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/f6b33b86-5eb3-41dd-83f7-9e0a0382507b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'castellated-beam-calculator.html:677',message:'입력값 읽기 완료',data:{qD:qD,self_w:self_w,slabWeight:slabWeight,B:B},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
                // #endregion
                const steelGrade = document.getElementById('steelGrade').value;
                const Fy = getFy(steelGrade);
                
                // Section dimensions (dc는 mm 단위로 입력받고, m 단위로 변환)
                const dc = (parseFloat(document.getElementById('beamDepth').value) || 0) / 1000;  // mm → m
                const bf = parseFloat(document.getElementById('flangeWidth').value) || 0;
                const tf = parseFloat(document.getElementById('flangeThickness').value) || 0;
                const tw = parseFloat(document.getElementById('webThickness').value) || 0;
                
                // Opening parameters
                const ho = parseFloat(document.getElementById('openingHeight').value) || 0;
                const p = parseFloat(document.getElementById('openingSpacing').value) || 0;
                const theta = parseFloat(document.getElementById('openingAngle').value) || 0;
                const end_post = parseFloat(document.getElementById('endPost').value) || 0;
                const e = parseFloat(document.getElementById('openingWidth').value) || 0;
                
                // Slab thickness
                const ts = parseFloat(document.getElementById('slabThickness').value) || 0;

                // Validation
                if (L <= 0 || B <= 0) {
                    alert('보 스팬과 하중 폭을 입력해주세요.');
                    return;
                }
                if (dc <= 0 || bf <= 0 || tf <= 0 || tw <= 0) {
                    alert('원단면 치수를 모두 입력해주세요.');
                    return;
                }
                if (ho <= 0 || p <= 0 || e <= 0) {
                    alert('개구부 정보를 모두 입력해주세요.');
                    return;
                }

                // Convert distributed loads to line loads (kN/m)
                // 고정하중 = Super imposed Dead Load + 보 자중 + 슬래브 자중
                const qD_total = qD + self_w + slabWeight;  // kN/m²
                const DL = qD_total * B;  // kN/m
                const LL = qL * B;  // kN/m
                
                // 보 자중을 선하중으로 변환 (결과 표시용)
                const self_w_kNm = self_w * B;  // kN/m
                
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/f6b33b86-5eb3-41dd-83f7-9e0a0382507b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'castellated-beam-calculator.html:717',message:'고정하중 계산 확인',data:{qD:qD,self_w:self_w,slabWeight:slabWeight,qD_total:qD_total,DL:DL,B:B},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
                // #endregion
                
                // Total factored load (LRFD)
                // DL에 이미 보 자중과 슬래브 자중이 포함되어 있음
                const wu = 1.2 * DL + 1.6 * LL;  // kN/m

                // Construction stage calculations (시공단계 계산)
                const Es = 200000; // MPa (강재 탄성계수)
                // 시공중 고정하중: 슬래브 자중 + 철골보 자중
                const w_DL_construction = (slabWeight + self_w) * B; // kN/m
                // 시공중 활하중: Construction Load
                const w_CLL_construction = qConst * B; // kN/m
                // 시공중 계수하중 (LRFD): max[1.4*DL, 1.2*DL + 1.6*LL]
                const w_u1_construction = 1.4 * w_DL_construction; // kN/m
                const w_u2_construction = 1.2 * w_DL_construction + 1.6 * w_CLL_construction; // kN/m
                const w_u_construction = Math.max(w_u1_construction, w_u2_construction); // kN/m
                // 시공 중 소요휨강도
                const M_u_construction = w_u_construction * Math.pow(L, 2) / 8; // kN·m
                // 시공 중 소요단면2차모멘트 (처짐 제한 60mm 고려)
                const delta_allow_construction = 60; // mm (콘크리트 타설 시공성 고려)
                const I_req_construction = (5 * w_DL_construction * Math.pow(L * 1000, 4)) / (384 * Es * delta_allow_construction); // mm⁴
                
                // Castellated beam 단면2차모멘트 계산
                // Castellated beam 높이 = dc (이미 castellated beam으로 제작됨)
                const d_castellated = dc * 1000; // mm (Castellated beam 높이)
                const hw_castellated = d_castellated - 2 * tf; // mm
                
                // 필렛 반경 (r값) 가져오기
                const r = parseFloat(document.getElementById('filletRadius')?.value) || 0; // mm
                
                // Castellated beam 단면 2차 모멘트: Ix = I_flange + I_web - I_fillet (r값 고려)
                // 플랜지: (bf * tf^3) / 12 + (bf * tf) * ((d - tf) / 2)^2 (상하 각각)
                // 웹: (tw * hw^3) / 12
                const I_flange = (bf * Math.pow(tf, 3)) / 12; // 플랜지 자체 모멘트
                const A_flange = bf * tf; // 플랜지 단면적
                const y_flange = (d_castellated - tf) / 2; // 플랜지 중심까지 거리
                const I_flange_parallel = A_flange * Math.pow(y_flange, 2); // 평행축 정리
                const I_web = (tw * Math.pow(hw_castellated, 3)) / 12; // 웹 모멘트
                
                // r값을 고려한 필렛 부분 모멘트 감소 (근사 계산)
                // 필렛은 1/4 원형으로 근사, 각 모서리에서 제거되는 면적: A_fillet = r²(1 - π/4) ≈ 0.2146r²
                // 필렛 부분의 모멘트는 작지만, 보정 계수를 사용하여 근사적으로 반영
                // 일반적으로 r값이 작을 때는 영향이 미미하지만, 정확도를 위해 보정 계수 적용
                let I_fillet_correction = 0;
                if (r > 0) {
                    // 필렛 부분 면적 (4개 모서리)
                    const A_fillet_total = 4 * (r * r - Math.PI * r * r / 4); // mm²
                    // 필렛 부분의 모멘트 감소 (근사: 필렛 중심까지 거리를 평균적으로 고려)
                    const y_fillet = (d_castellated - tf) / 2; // 필렛 중심까지 거리 (플랜지 중심과 동일)
                    I_fillet_correction = A_fillet_total * Math.pow(y_fillet, 2); // mm⁴
                }
                
                const Ix_steel = I_flange * 2 + I_flange_parallel * 2 + I_web - I_fillet_correction; // mm⁴
                
                // 원단면(H형강) 단면2차모멘트 계산 (비교용)
                const d_original = d_castellated / 1.5; // mm (원단면 높이)
                const hw_original = d_original - 2 * tf; // mm
                const I_flange_original = (bf * Math.pow(tf, 3)) / 12; // 플랜지 자체 모멘트
                const A_flange_original = bf * tf; // 플랜지 단면적
                const y_flange_original = (d_original - tf) / 2; // 플랜지 중심까지 거리
                const I_flange_parallel_original = A_flange_original * Math.pow(y_flange_original, 2); // 평행축 정리
                const I_web_original = (tw * Math.pow(hw_original, 3)) / 12; // 웹 모멘트
                let I_fillet_correction_original = 0;
                if (r > 0) {
                    const A_fillet_total_original = 4 * (r * r - Math.PI * r * r / 4); // mm²
                    const y_fillet_original = (d_original - tf) / 2;
                    I_fillet_correction_original = A_fillet_total_original * Math.pow(y_fillet_original, 2); // mm⁴
                }
                const Ix_original = I_flange_original * 2 + I_flange_parallel_original * 2 + I_web_original - I_fillet_correction_original; // mm⁴
                
                // 단면적 계산 (원 beam과 castellated beam 동일)
                const A_total = bf * tf * 2 + hw_castellated * tw; // mm²
                if (r > 0) {
                    const A_fillet_total = 4 * (r * r - Math.PI * r * r / 4); // mm²
                    // 단면적에서 필렛 부분 제거는 하지 않음 (근사적으로 무시)
                }
                
                // 단면계수 계산
                const Sx_original = Ix_original / (d_original / 2); // mm³
                const Sx_castellated = Ix_steel / (d_castellated / 2); // mm³
                
                // 회전반경 계산
                const rx_original = Math.sqrt(Ix_original / A_total); // mm
                const rx_castellated = Math.sqrt(Ix_steel / A_total); // mm
                
                // Iy 계산 (Y축 단면2차모멘트)
                const Iy_flange = (tf * Math.pow(bf, 3)) / 12; // 플랜지 Y축 모멘트
                const Iy_web = (hw_castellated * Math.pow(tw, 3)) / 12; // 웹 Y축 모멘트
                const Iy_original = Iy_flange * 2 + Iy_web; // mm⁴
                const Iy_castellated = Iy_original; // Y축은 높이 변화 없으므로 동일
                const ry_original = Math.sqrt(Iy_original / A_total); // mm
                const ry_castellated = ry_original; // Y축 회전반경도 동일
                
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/f6b33b86-5eb3-41dd-83f7-9e0a0382507b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'castellated-beam-calculator.html:809',message:'Castellated beam Ix 계산',data:{dc:dc,d_castellated:d_castellated,bf:bf,tf:tf,tw:tw,hw_castellated:hw_castellated,r:r,I_flange:I_flange,A_flange:A_flange,y_flange:y_flange,I_flange_parallel:I_flange_parallel,I_web:I_web,I_fillet_correction:I_fillet_correction,Ix_steel:Ix_steel,Ix_steel_M6:Ix_steel/1e6},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
                // #endregion

                // Service stage calculations (사용단계 계산)
                // 합성 전 고정하중: 슬래브 자중 + 철골보 자중
                const w_DL_service = (slabWeight + self_w) * B; // kN/m
                // 합성 후 고정하중: Dead Load (합성 후 추가 고정하중)
                const w_SIDL_service = qD * B; // kN/m
                // 합성 후 활하중: Live Load
                const w_LL_service = qL * B; // kN/m
                // 사용 중 계수하중 (LRFD): max[1.4*(DL+SIDL), 1.2*(DL+SIDL) + 1.6*LL]
                const w_u1_service = 1.4 * (w_DL_service + w_SIDL_service); // kN/m
                const w_u2_service = 1.2 * (w_DL_service + w_SIDL_service) + 1.6 * w_LL_service; // kN/m
                const w_u_service = Math.max(w_u1_service, w_u2_service); // kN/m
                // 사용 중 소요휨강도
                const M_u_service = w_u_service * Math.pow(L, 2) / 8; // kN·m
                // 사용 중 소요전단강도
                const V_u_service = w_u_service * L / 2; // kN
                // 사용 중 소요단면 2차 모멘트 (처짐 제한 L/360 고려)
                const delta_allow_service = (L * 1000) / 360; // mm (L/360)
                const I_req_service = (5 * w_LL_service * Math.pow(L * 1000, 4)) / (384 * Es * delta_allow_service); // mm⁴

                // Shear and moment functions
                function Vx(x) {
                    return 0.5 * wu * L - wu * x;
                }

                function Mx(x) {
                    return 0.5 * wu * x * (L - x);
                }

                // Calculate opening parameters
                // e = 웹 포스트 폭 (개구부 사이 남는 웹 두께 방향 폭) - 입력값
                // W_rect = 개구부 폭 (직사각형 부분) - 계산 필요
                // W_open = 개구부 전체 폭 (직사각형 + 삼각형 부분)
                // p = 개구부 간격 = W_open + e
                const delta_x = (ho * 1000.0) / (2.0 * Math.sqrt(3.0));  // mm
                // p에서 e를 빼면 W_open이 됨: W_open = p - e
                const W_open = p * 1000.0 - e;  // mm (개구부 전체 폭)
                const W_rect = W_open - 2.0 * delta_x;  // mm (개구부 폭, 직사각형 부분)
                const b_wp = e;  // mm (웹 포스트 폭 = e)

                // Number of openings
                // 웹 포스트 폭(e)이 커지면 p = W_open + e가 커지고, 따라서 N = L_open / p가 작아짐
                const L_open = L - 2.0 * end_post;
                const N = Math.round(L_open / p);
                
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/f6b33b86-5eb3-41dd-83f7-9e0a0382507b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'castellated-beam-calculator.html:889',message:'개구부 개수 계산',data:{L:L,end_post:end_post,L_open:L_open,p:p,N:N,e:e,W_open:W_open,W_rect:W_rect,b_wp:b_wp},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
                // #endregion
                
                const x1 = end_post + 0.5 * p;
                const xs = [];
                for (let i = 0; i < N; i++) {
                    xs.push(x1 + i * p);
                }

                // Tee section properties (these would normally be calculated from section geometry)
                // For now, using placeholder values - these should be calculated based on actual Tee section
                const phiPn = 1553.7;  // kN (placeholder - should be calculated)
                const phiMn = 21.47;   // kN·m (placeholder - should be calculated)
                const d_eff = 0.8379;  // m (placeholder - should be calculated)
                const h_top = 0.4189;  // m (placeholder - should be calculated)
                // Mtee 계산: 개구부 폭(W_rect)의 1/4 사용
                // Python 코드의 e는 개구부 폭을 의미하며, 웹포스트 폭(e)이 증가해도
                // 개구부 폭(W_rect)은 변하지 않으므로 UR이 안정적으로 유지됨
                const W_rect_over_4 = (W_rect / 4.0) / 1000.0;  // m (개구부 폭 사용)

                // Calculate for each opening
                const openingResults = [];
                let maxUR = 0;
                let maxURIndex = 0;
                
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/f6b33b86-5eb3-41dd-83f7-9e0a0382507b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'castellated-beam-calculator.html:915',message:'UR 계산 시작 (수정 후: W_rect 사용)',data:{N:N,e:e,W_rect:W_rect,W_rect_over_4:W_rect_over_4,phiPn:phiPn,phiMn:phiMn,d_eff:d_eff},timestamp:Date.now(),sessionId:'debug-session',runId:'post-fix',hypothesisId:'A'})}).catch(()=>{});
                // #endregion
                
                for (let i = 0; i < xs.length; i++) {
                    const x = xs[i];
                    const V = Vx(x);
                    const M = Mx(x);
                    const P = M / d_eff;
                    // Mtee 계산: 개구부 폭(W_rect) 사용 (로그 분석 결과 올바른 방법)
                    // Python 코드의 e는 개구부 폭을 의미하며, 웹포스트 폭(e)이 증가해도
                    // 개구부 폭(W_rect)은 변하지 않으므로 UR이 안정적으로 유지됨
                    const Mtee = Math.abs(V) * W_rect_over_4;  // 개구부 폭 사용
                    const UR = Math.abs(P) / phiPn + Mtee / phiMn;
                    
                    // #region agent log
                    // 수정 후 검증을 위한 로그 (W_rect 사용)
                    fetch('http://127.0.0.1:7242/ingest/f6b33b86-5eb3-41dd-83f7-9e0a0382507b',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'castellated-beam-calculator.html:957',message:'개구부별 UR 계산 (수정 후: W_rect 사용)',data:{i:i+1,x:x,V:V,M:M,P:P,e:e,W_rect:W_rect,W_open:W_open,W_rect_over_4:W_rect_over_4,Mtee:Mtee,UR:UR,phiPn:phiPn,phiMn:phiMn},timestamp:Date.now(),sessionId:'debug-session',runId:'post-fix',hypothesisId:'A'})}).catch(()=>{});
                    // #endregion
                    
                    openingResults.push({
                        i: i + 1,
                        x: x,
                        V: V,
                        M: M,
                        P: P,
                        Mtee: Mtee,
                        UR: UR
                    });
                    
                    if (UR > maxUR) {
                        maxUR = UR;
                        maxURIndex = i;
                    }
                }

                // Governing opening
                const govOpening = openingResults[maxURIndex];

                // Governing web-post (maximum dP)
                let maxDP = 0;
                let maxDPIndex = 0;
                for (let i = 1; i < openingResults.length; i++) {
                    const dP = Math.abs(openingResults[i].P - openingResults[i-1].P);
                    if (dP > maxDP) {
                        maxDP = dP;
                        maxDPIndex = i;
                    }
                }
                const Vrh = maxDP;
                const webPostPair = [openingResults[maxDPIndex - 1].i, openingResults[maxDPIndex].i];

                // Web-post buckling (DG31)
                // Mp 계산: 개구부 전체 폭(W_open) 사용
                const Mp = (0.25 * tw * Math.pow(W_open, 2) * Fy) / 1e6;  // kN·m
                const etw = e / tw;  // 웹 포스트 폭비
                const r10 = 0.408;
                const r20 = 0.437;
                let ratio;
                if (etw <= 10) {
                    ratio = r10;
                } else if (etw >= 20) {
                    ratio = r20;
                } else {
                    ratio = r10 + (r20 - r10) * ((etw - 10) / 10);
                }
                const Mocr = ratio * Mp;
                const phi_b = 0.90;
                const phiMocr = phi_b * Mocr;
                const Mrh = Vrh * h_top;
                const buckling_ok = Mrh <= phiMocr;

                // Weld design
                const Fexx = 490.0;  // MPa
                const phi_w = 0.75;
                const Aw_req = (Vrh * 1000.0) / (phi_w * 0.6 * Fexx);  // mm²
                const w_req = Aw_req / (0.707 * e);  // mm
                const w_final = Math.ceil(w_req);  // mm

                // Prepare results
                const results = {
                    type: beamType,
                    L: L,
                    B: B,
                    DL: DL,
                    LL: LL,
                    self_w: self_w,  // kN/m²
                    slabWeight: slabWeight,  // kN/m²
                    self_w_kNm: self_w_kNm,  // kN/m
                    wu: wu,
                    Fy: Fy,
                    steelGrade: steelGrade,
                    dc: dc,
                    bf: bf,
                    tf: tf,
                    tw: tw,
                    ho: ho,
                    p: p,
                    theta: theta,
                    end_post: end_post,
                    e: e,  // 웹 포스트 폭
                    delta_x: delta_x,
                    W_open: W_open,  // 개구부 전체 폭
                    W_rect: W_rect,  // 개구부 폭 (직사각형 부분)
                    b_wp: b_wp,  // 웹 포스트 폭 (= e)
                    N: N,
                    openingResults: openingResults,
                    govOpening: govOpening,
                    Vrh: Vrh,
                    webPostPair: webPostPair,
                    Mrh: Mrh,
                    Mp: Mp,
                    etw: etw,
                    ratio: ratio,
                    Mocr: Mocr,
                    phiMocr: phiMocr,
                    buckling_ok: buckling_ok,
                    w_req: w_req,
                    w_final: w_final,
                    ts: ts,
                    // Construction stage results
                    qConst: qConst,
                    w_DL_construction: w_DL_construction,
                    w_CLL_construction: w_CLL_construction,
                    w_u1_construction: w_u1_construction,
                    w_u2_construction: w_u2_construction,
                    w_u_construction: w_u_construction,
                    M_u_construction: M_u_construction,
                    I_req_construction: I_req_construction,
                    Ix_steel: Ix_steel,
                    delta_allow_construction: delta_allow_construction,
                    // Section properties
                    d_original: d_original,
                    Ix_original: Ix_original,
                    Sx_original: Sx_original,
                    rx_original: rx_original,
                    Iy_original: Iy_original,
                    ry_original: ry_original,
                    d_castellated: d_castellated,
                    Sx_castellated: Sx_castellated,
                    rx_castellated: rx_castellated,
                    Iy_castellated: Iy_castellated,
                    ry_castellated: ry_castellated,
                    A_total: A_total,
                    // Service stage results
                    w_DL_service: w_DL_service,
                    w_SIDL_service: w_SIDL_service,
                    w_LL_service: w_LL_service,
                    w_u1_service: w_u1_service,
                    w_u2_service: w_u2_service,
                    w_u_service: w_u_service,
                    M_u_service: M_u_service,
                    V_u_service: V_u_service,
                    I_req_service: I_req_service,
                    delta_allow_service: delta_allow_service
                };

                displayResults(results);
            } catch (error) {
                console.error('Calculation error:', error);
                alert('계산 중 오류가 발생했습니다: ' + error.message);
            }
        }

        // Display results
        function displayResults(results) {
            const container = document.getElementById('resultsContainer');
            const noResults = document.getElementById('noResults');

            if (!container) return;

            container.classList.add('active');
            if (noResults) {
                noResults.style.display = 'none';
            }

            // Create opening results table
            let openingTableRows = '';
            results.openingResults.forEach(op => {
                const urStatus = op.UR <= 1.0 ? 'status-ok' : 'status-ng';
                openingTableRows += `
                    <tr>
                        <td>${op.i}</td>
                        <td>${formatNumber(op.x, 2)}</td>
                        <td>${formatNumber(op.V, 2)}</td>
                        <td>${formatNumber(op.M, 2)}</td>
                        <td>${formatNumber(op.P, 2)}</td>
                        <td>${formatNumber(op.Mtee, 2)}</td>
                        <td class="result-value ${urStatus}">${formatNumber(op.UR, 3)}</td>
                    </tr>
                `;
            });

            container.innerHTML = `
                <!-- 1. 입력 조건 -->
                <div class="result-section">
                    <div class="result-section-title">1. 입력 조건</div>
                    <table class="result-table">
                        <tr>
                            <th>항목</th>
                            <th>값</th>
                            <th>단위</th>
                        </tr>
                        <tr>
                            <td>계산 타입</td>
                            <td class="result-value">${results.type === 'with-slab' ? 'with top-slab' : 'without top-slab'}</td>
                            <td>-</td>
                        </tr>
                        <tr>
                            <td>보 스팬 (L)</td>
                            <td class="result-value">${formatNumber(results.L, 2)}</td>
                            <td>m</td>
                        </tr>
                        <tr>
                            <td>하중 폭 (B)</td>
                            <td class="result-value">${formatNumber(results.B, 2)}</td>
                            <td>m</td>
                        </tr>
                        <tr>
                            <td>고정하중 (DL)</td>
                            <td class="result-value">${formatNumber(results.DL, 2)}</td>
                            <td>kN/m</td>
                        </tr>
                        <tr>
                            <td>활하중 (LL)</td>
                            <td class="result-value">${formatNumber(results.LL, 2)}</td>
                            <td>kN/m</td>
                        </tr>
                        <tr>
                            <td>보 자중 (self_w)</td>
                            <td class="result-value">${formatNumber(results.self_w, 3)}</td>
                            <td>kN/m²</td>
                        </tr>
                        <tr>
                            <td>보 자중 (self_w × B)</td>
                            <td class="result-value">${formatNumber(results.self_w_kNm, 2)}</td>
                            <td>kN/m</td>
                        </tr>
                        <tr>
                            <td>계수하중 (wu)<br><span style="font-size: 11px; color: #64748b; font-weight: normal;">LRFD: 1.2D + 1.6L</span></td>
                            <td class="result-value">${formatNumber(results.wu, 2)}</td>
                            <td>kN/m</td>
                        </tr>
                        <tr>
                            <td>강종</td>
                            <td class="result-value">${results.steelGrade} (Fy = ${results.Fy} MPa)</td>
                            <td>-</td>
                        </tr>
                        <tr>
                            <td>원단면</td>
                            <td class="result-value">H${(results.dc*1000).toFixed(0)}×${results.bf}×${results.tw}×${results.tf}</td>
                            <td>-</td>
                        </tr>
                        ${results.type === 'with-slab' ? `
                        <tr>
                            <td>슬래브 두께 (ts)</td>
                            <td class="result-value">${formatNumber(results.ts, 0)}</td>
                            <td>mm</td>
                        </tr>
                        ` : ''}
                        <tr>
                            <td>개구부 높이 (ho)</td>
                            <td class="result-value">${formatNumber(results.ho, 2)}</td>
                            <td>m</td>
                        </tr>
                    </table>
                </div>

                <!-- 원단면 Section Properties -->
                <div class="result-section">
                    <div class="result-section-title">원단면 (H형강) Section Properties</div>
                    <table class="result-table">
                        <tr>
                            <th>항목</th>
                            <th>값</th>
                            <th>단위</th>
                        </tr>
                        <tr>
                            <td>높이 (d)</td>
                            <td class="result-value">${formatNumber(results.d_original, 1)}</td>
                            <td>mm</td>
                        </tr>
                        <tr>
                            <td>단면적 (A)</td>
                            <td class="result-value">${formatNumber(results.A_total, 1)}</td>
                            <td>mm²</td>
                        </tr>
                        <tr>
                            <td>단면2차모멘트 (Ix)</td>
                            <td class="result-value">${formatNumber(results.Ix_original / 1e6, 2)}</td>
                            <td>×10⁶ mm⁴</td>
                        </tr>
                        <tr>
                            <td>단면2차모멘트 (Iy)</td>
                            <td class="result-value">${formatNumber(results.Iy_original / 1e6, 2)}</td>
                            <td>×10⁶ mm⁴</td>
                        </tr>
                        <tr>
                            <td>단면계수 (Sx)</td>
                            <td class="result-value">${formatNumber(results.Sx_original / 1e3, 1)}</td>
                            <td>×10³ mm³</td>
                        </tr>
                        <tr>
                            <td>회전반경 (rx)</td>
                            <td class="result-value">${formatNumber(results.rx_original, 1)}</td>
                            <td>mm</td>
                        </tr>
                        <tr>
                            <td>회전반경 (ry)</td>
                            <td class="result-value">${formatNumber(results.ry_original, 1)}</td>
                            <td>mm</td>
                        </tr>
                    </table>
                </div>

                <!-- Castellated Beam Section Properties -->
                <div class="result-section">
                    <div class="result-section-title">Castellated Beam Section Properties</div>
                    <table class="result-table">
                        <tr>
                            <th>항목</th>
                            <th>값</th>
                            <th>단위</th>
                        </tr>
                        <tr>
                            <td>높이 (dc)</td>
                            <td class="result-value">${formatNumber(results.d_castellated, 1)}</td>
                            <td>mm</td>
                        </tr>
                        <tr>
                            <td>단면적 (A)</td>
                            <td class="result-value">${formatNumber(results.A_total, 1)}</td>
                            <td>mm²</td>
                        </tr>
                        <tr>
                            <td>단면2차모멘트 (Ix)</td>
                            <td class="result-value">${formatNumber(results.Ix_steel / 1e6, 2)}</td>
                            <td>×10⁶ mm⁴</td>
                        </tr>
                        <tr>
                            <td>단면2차모멘트 (Iy)</td>
                            <td class="result-value">${formatNumber(results.Iy_castellated / 1e6, 2)}</td>
                            <td>×10⁶ mm⁴</td>
                        </tr>
                        <tr>
                            <td>단면계수 (Sx)</td>
                            <td class="result-value">${formatNumber(results.Sx_castellated / 1e3, 1)}</td>
                            <td>×10³ mm³</td>
                        </tr>
                        <tr>
                            <td>회전반경 (rx)</td>
                            <td class="result-value">${formatNumber(results.rx_castellated, 1)}</td>
                            <td>mm</td>
                        </tr>
                        <tr>
                            <td>회전반경 (ry)</td>
                            <td class="result-value">${formatNumber(results.ry_castellated, 1)}</td>
                            <td>mm</td>
                        </tr>
                    </table>
                </div>

                <!-- 2. 개구부별 계산 결과 -->
                <div class="result-section">
                    <div class="result-section-title">2. 개구부별 계산 결과</div>
                    <div style="overflow-x: auto;">
                        <table class="result-table">
                            <thead>
                                <tr>
                                    <th>i</th>
                                    <th>x (m)</th>
                                    <th>V(x) (kN)</th>
                                    <th>M(x) (kN·m)</th>
                                    <th>P_i (kN)</th>
                                    <th>M_tee,i (kN·m)</th>
                                    <th>UR_i</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${openingTableRows}
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- 3. 지배 개구부 -->
                <div class="result-section">
                    <div class="result-section-title">3. 지배 개구부 (Governing Opening)</div>
                    <table class="result-table">
                        <tr>
                            <th>항목</th>
                            <th>값</th>
                            <th>단위</th>
                        </tr>
                        <tr>
                            <td>개구부 번호 (i)</td>
                            <td class="result-value">${results.govOpening.i}</td>
                            <td>-</td>
                        </tr>
                        <tr>
                            <td>위치 (x)</td>
                            <td class="result-value">${formatNumber(results.govOpening.x, 2)}</td>
                            <td>m</td>
                        </tr>
                        <tr>
                            <td>전단력 V(x)</td>
                            <td class="result-value">${formatNumber(results.govOpening.V, 2)}</td>
                            <td>kN</td>
                        </tr>
                        <tr>
                            <td>모멘트 M(x)</td>
                            <td class="result-value">${formatNumber(results.govOpening.M, 2)}</td>
                            <td>kN·m</td>
                        </tr>
                        <tr>
                            <td>축력 P_i</td>
                            <td class="result-value">${formatNumber(results.govOpening.P, 2)}</td>
                            <td>kN</td>
                        </tr>
                        <tr>
                            <td>Tee 모멘트 M_tee,i</td>
                            <td class="result-value">${formatNumber(results.govOpening.Mtee, 2)}</td>
                            <td>kN·m</td>
                        </tr>
                        <tr>
                            <td>이용률 UR_i</td>
                            <td class="result-value ${results.govOpening.UR <= 1.0 ? 'status-ok' : 'status-ng'}">${formatNumber(results.govOpening.UR, 3)}</td>
                            <td>-</td>
                        </tr>
                        <tr>
                            <td>검토 결과</td>
                            <td class="result-value ${results.govOpening.UR <= 1.0 ? 'status-ok' : 'status-ng'}">
                                ${results.govOpening.UR <= 1.0 ? '✅ 만족' : '❌ 불만족'}
                            </td>
                            <td>-</td>
                        </tr>
                    </table>
                </div>

                <!-- 4. 지배 Web-Post -->
                <div class="result-section">
                    <div class="result-section-title">4. 지배 Web-Post (Governing Web-Post)</div>
                    <table class="result-table">
                        <tr>
                            <th>항목</th>
                            <th>값</th>
                            <th>단위</th>
                        </tr>
                        <tr>
                            <td>Web-Post 쌍</td>
                            <td class="result-value">${results.webPostPair[0]} - ${results.webPostPair[1]}</td>
                            <td>-</td>
                        </tr>
                        <tr>
                            <td>전단력 V_rh</td>
                            <td class="result-value">${formatNumber(results.Vrh, 2)}</td>
                            <td>kN</td>
                        </tr>
                        <tr>
                            <td>모멘트 M_rh</td>
                            <td class="result-value">${formatNumber(results.Mrh, 2)}</td>
                            <td>kN·m</td>
                        </tr>
                    </table>
                </div>

                <!-- 5. Web-Post Buckling 검토 (DG31) -->
                <div class="result-section">
                    <div class="result-section-title">5. Web-Post Buckling 검토 (AISC DG31)</div>
                    <table class="result-table">
                        <tr>
                            <th>항목</th>
                            <th>값</th>
                            <th>단위</th>
                        </tr>
                        <tr>
                            <td>소성 모멘트 (Mp)</td>
                            <td class="result-value">${formatNumber(results.Mp, 2)}</td>
                            <td>kN·m</td>
                        </tr>
                        <tr>
                            <td>e/tw</td>
                            <td class="result-value">${formatNumber(results.etw, 2)}</td>
                            <td>-</td>
                        </tr>
                        <tr>
                            <td>비율 (ratio)</td>
                            <td class="result-value">${formatNumber(results.ratio, 3)}</td>
                            <td>-</td>
                        </tr>
                        <tr>
                            <td>좌굴 모멘트 (Mocr)</td>
                            <td class="result-value">${formatNumber(results.Mocr, 2)}</td>
                            <td>kN·m</td>
                        </tr>
                        <tr>
                            <td>설계 좌굴 모멘트 (φMocr)</td>
                            <td class="result-value">${formatNumber(results.phiMocr, 2)}</td>
                            <td>kN·m</td>
                        </tr>
                        <tr>
                            <td>소요 모멘트 (M_rh)</td>
                            <td class="result-value">${formatNumber(results.Mrh, 2)}</td>
                            <td>kN·m</td>
                        </tr>
                        <tr>
                            <td>검토 결과</td>
                            <td class="result-value ${results.buckling_ok ? 'status-ok' : 'status-ng'}">
                                ${results.buckling_ok ? '✅ 만족' : '❌ 불만족'}
                            </td>
                            <td>-</td>
                        </tr>
                    </table>
                </div>

                <!-- 7. 가설하중 검토 -->
                <div class="result-section">
                    <div class="result-section-title" style="font-size: 18px; font-weight: 700; color: #1e3a5f; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #cbd5e1;">1. 작용하중단계별 소요강도 및 소요단면 2차 모멘트</div>
                    <div class="result-section-title">1.1 시공단계의 소요강도 및 소요단면 2차 모멘트</div>
                    <div style="font-size: 12px; color: #64748b; margin-bottom: 15px; padding: 8px; background: #f1f5f9; border-radius: 4px;">
                        간격 ${formatNumber(results.B, 1)}m의 보에 대한 선형등분포하중을 산정하여 작용하중단계별 소요휨강도, 소요전단강도, 소요단면 2차 모멘트를 구한다.
                    </div>
                    
                    <div style="margin-bottom: 20px;">
                        <h4 style="font-size: 14px; font-weight: 600; color: #1e3a5f; margin-bottom: 10px;">1) 선형등분포하중</h4>
                        <div style="font-size: 12px; color: #475569; line-height: 1.8; font-family: 'Courier New', monospace; background: #f8fafc; padding: 12px; border-radius: 6px; border: 1px solid #e2e8f0;">
                            <div>시공중 고정하중: w_DL = (${formatNumber(results.slabWeight || 0, 2)} + ${formatNumber(results.self_w, 2)})(${formatNumber(results.B, 2)}) = ${formatNumber(results.w_DL_construction, 2)} kN/m</div>
                            <div>시공중 활하중: w_CLL = (${formatNumber(results.qConst || 0, 2)})(${formatNumber(results.B, 2)}) = ${formatNumber(results.w_CLL_construction, 3)} kN/m</div>
                            <div style="margin-top: 12px; font-weight: 600;">시공중 계수하중:</div>
                            <div style="margin-left: 20px;">w_u1 = 1.4DL = 1.4(${formatNumber(results.w_DL_construction, 3)}) = ${formatNumber(results.w_u1_construction, 3)} kN/m</div>
                            <div style="margin-left: 20px;">w_u2 = 1.2DL + 1.6LL = 1.2(${formatNumber(results.w_DL_construction, 3)}) + 1.6(${formatNumber(results.w_CLL_construction, 3)}) = ${formatNumber(results.w_u2_construction, 3)} kN/m</div>
                            <div style="margin-left: 20px; font-weight: 600;">∴ w_u = max.[w_u1, w_u2] = ${formatNumber(results.w_u_construction, 3)} kN/m</div>
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <h4 style="font-size: 14px; font-weight: 600; color: #1e3a5f; margin-bottom: 10px;">2) 시공 중 강재보의 소요휨강도</h4>
                        <div style="font-size: 12px; color: #475569; line-height: 1.8; font-family: 'Courier New', monospace; background: #f8fafc; padding: 12px; border-radius: 6px; border: 1px solid #e2e8f0;">
                            <div>시공 중 소요휨강도: M_u = (w_u × l²) / 8 = (${formatNumber(results.w_u_construction, 3)})(${formatNumber(results.L, 2)})² / 8 = ${formatNumber(results.M_u_construction, 2)} kN·m</div>
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <h4 style="font-size: 14px; font-weight: 600; color: #1e3a5f; margin-bottom: 10px;">3) 시공 중 강재보의 소요단면2차모멘트</h4>
                        <div style="font-size: 12px; color: #475569; line-height: 1.8; font-family: 'Courier New', monospace; background: #f8fafc; padding: 12px; border-radius: 6px; border: 1px solid #e2e8f0;">
                            <div>시공 중 강재보의 처짐은 콘크리트 타설의 시공성을 고려하여 ${formatNumber(results.delta_allow_construction, 0)}mm로 제한한다.</div>
                            <div style="margin-top: 8px;">시공 중 소요단면2차모멘트: I_req = (5 × w_DL × l⁴) / (384 × E × Δ)</div>
                            <div style="margin-left: 20px;">I_req = (5 × ${formatNumber(results.w_DL_construction, 3)} × ${formatNumber(results.L * 1000, 0)}⁴) / (384 × ${formatNumber(200000 / 1000, 0)} × ${formatNumber(results.delta_allow_construction, 0)})</div>
                            <div style="margin-left: 20px;">I_req = ${formatNumber(results.I_req_construction / 1e6, 2)} × 10⁶ mm⁴</div>
                            <div style="margin-top: 8px; font-size: 11px; color: #64748b; font-style: italic;">※ 시공단계에서 이미 Castellated beam으로 제작되었으므로, Castellated beam의 단면2차모멘트를 사용합니다.</div>
                        </div>
                    </div>

                    <table class="result-table">
                        <tr>
                            <th>항목</th>
                            <th>값</th>
                            <th>단위</th>
                        </tr>
                        <tr>
                            <td>시공중 고정하중 (w_DL)</td>
                            <td class="result-value">${formatNumber(results.w_DL_construction, 3)}</td>
                            <td>kN/m</td>
                        </tr>
                        <tr>
                            <td>시공중 활하중 (w_CLL)</td>
                            <td class="result-value">${formatNumber(results.w_CLL_construction, 3)}</td>
                            <td>kN/m</td>
                        </tr>
                        <tr>
                            <td>시공중 계수하중 (w_u)</td>
                            <td class="result-value">${formatNumber(results.w_u_construction, 3)}</td>
                            <td>kN/m</td>
                        </tr>
                        <tr>
                            <td>시공 중 소요휨강도 (M_u)</td>
                            <td class="result-value">${formatNumber(results.M_u_construction, 2)}</td>
                            <td>kN·m</td>
                        </tr>
                        <tr>
                            <td>시공 중 소요단면2차모멘트 (I_req)</td>
                            <td class="result-value">${formatNumber(results.I_req_construction / 1e6, 2)}</td>
                            <td>×10⁶ mm⁴</td>
                        </tr>
                        <tr>
                            <td>강재보 단면2차모멘트 (Ix_steel)<br><span style="font-size: 11px; color: #64748b; font-weight: normal;">Castellated beam</span></td>
                            <td class="result-value">${formatNumber(results.Ix_steel / 1e6, 2)}</td>
                            <td>×10⁶ mm⁴</td>
                        </tr>
                        <tr>
                            <td>처짐 제한 (시공성 고려)</td>
                            <td class="result-value">${formatNumber(results.delta_allow_construction, 0)}</td>
                            <td>mm</td>
                        </tr>
                    </table>
                    ${results.Ix_steel < results.I_req_construction ? 
                        '<div class="warning-box"><strong>⚠️ 주의:</strong> 시공단계 소요단면2차모멘트를 만족하지 않습니다. 단면을 크게 하거나 보 스팬을 줄여주세요.</div>' : 
                        '<div style="background: #d1fae5; border: 1px solid #10b981; border-radius: 6px; padding: 12px; margin-top: 15px; font-size: 12px; color: #065f46;"><strong>✅ 확인:</strong> 시공단계 소요단면2차모멘트를 만족합니다.</div>'}
                </div>

                <!-- 6. 용접 설계 -->
                <div class="result-section">
                    <div class="result-section-title">6. 용접 설계</div>
                    <table class="result-table">
                        <tr>
                            <th>항목</th>
                            <th>값</th>
                            <th>단위</th>
                        </tr>
                        <tr>
                            <td>필요 용접 면적 (Aw_req)</td>
                            <td class="result-value">${formatNumber((results.Vrh * 1000.0) / (0.75 * 0.6 * 490.0), 2)}</td>
                            <td>mm²</td>
                        </tr>
                        <tr>
                            <td>필요 용접 크기 (w_req)</td>
                            <td class="result-value">${formatNumber(results.w_req, 2)}</td>
                            <td>mm</td>
                        </tr>
                        <tr>
                            <td>최종 용접 크기 (w_final)</td>
                            <td class="result-value">${results.w_final}</td>
                            <td>mm</td>
                        </tr>
                    </table>
                </div>
            `;
        }

        // 개구부 높이 자동 계산 함수 (ho ≤ 0.6dc)
        function updateOpeningHeight() {
            const beamDepthEl = document.getElementById('beamDepth');
            const openingHeightEl = document.getElementById('openingHeight');
            
            if (!beamDepthEl || !openingHeightEl) {
                return;
            }
            
            const dc = parseFloat(beamDepthEl.value) || 0;  // mm 단위
            if (dc > 0) {
                const ho = (0.6 * dc) / 1000;  // mm → m 변환
                openingHeightEl.value = ho.toFixed(3);
            }
        }

        // 개구부 간격 자동 계산 함수 (p = W_open + e)
        // e는 openingWidth (웹 포스트 폭, mm)
        // W_open = 개구부 전체 폭 = W_rect + 2*delta_x
        // W_rect는 개구부 폭 (직사각형 부분)으로, 일반적으로 원단면 높이(H)와 관련됨
        // 원치수 = beamDepth / 1.5
        // W_rect의 최소값은 H/2, 최대값은 1.5*ho
        // p = W_open + e = (W_rect + 2*delta_x) + e
        // 하지만 간단하게: p = (원치수 + 2*delta_x) + e (W_rect를 원치수로 근사)
        function updateOpeningSpacing() {
            const beamDepthEl = document.getElementById('beamDepth');
            const openingHeightEl = document.getElementById('openingHeight');
            const openingWidthEl = document.getElementById('openingWidth');
            const openingSpacingEl = document.getElementById('openingSpacing');
            
            if (!beamDepthEl || !openingHeightEl || !openingWidthEl || !openingSpacingEl) {
                return;
            }
            
            const dc = parseFloat(beamDepthEl.value) || 0;  // mm 단위
            const ho = parseFloat(openingHeightEl.value) || 0;  // m 단위
            const e = parseFloat(openingWidthEl.value) || 0;  // mm 단위 (웹 포스트 폭)
            
            if (dc > 0 && ho > 0 && e > 0) {
                // 원치수 = dc / 1.5
                const originalHeight = dc / 1.5;  // mm
                
                // delta_x 계산
                const hoMm = ho * 1000;  // m → mm
                const delta_x = hoMm / (2.0 * Math.sqrt(3.0));  // mm
                
                // W_rect는 일반적으로 원치수와 관련이 있지만, 정확한 값은 사용자 입력에 따라 달라짐
                // 여기서는 W_rect를 원치수로 근사 (실제로는 개구부 폭 입력이 필요하지만, 현재는 범위만 제공)
                // W_open = W_rect + 2*delta_x ≈ 원치수 + 2*delta_x
                const W_open = originalHeight + 2.0 * delta_x;  // mm (개구부 전체 폭)
                
                // p = W_open + e
                const p = (W_open + e) / 1000;  // mm → m 변환
                openingSpacingEl.value = p.toFixed(3);
                
                // 개구부 개수는 calculateBeam()에서 자동으로 재계산됨
                // p가 커지면 N = (L - 2*end_post) / p가 작아짐
            }
        }
        
        // 개구부 개수 계산 함수 (참고용)
        // N = (L - 2 * end_post) / p
        // openingWidth(e)가 커지면 p가 커지고, 따라서 N이 줄어듦
        function calculateOpeningCount() {
            const L = parseFloat(document.getElementById('beamSpan')?.value) || 0;  // m
            const end_post = parseFloat(document.getElementById('endPost')?.value) || 0;  // m
            const p = parseFloat(document.getElementById('openingSpacing')?.value) || 0;  // m
            
            if (L > 0 && end_post >= 0 && p > 0) {
                const L_open = L - 2.0 * end_post;
                const N = Math.round(L_open / p);
                return N;
            }
            return 0;
        }

        // End Post 길이 자동 계산 함수 (endPost = dc)
        function updateEndPost() {
            const beamDepthEl = document.getElementById('beamDepth');
            const endPostEl = document.getElementById('endPost');
            
            if (!beamDepthEl || !endPostEl) {
                return;
            }
            
            const dc = parseFloat(beamDepthEl.value) || 0;  // mm 단위
            if (dc > 0) {
                const endPost = dc / 1000;  // mm → m 변환
                endPostEl.value = endPost.toFixed(3);
            }
        }

        // 웹 포스트 폭(e) 범위 및 기본값 업데이트 함수
        // e = 웹 포스트 폭 (개구부 사이 남는 웹 두께 방향 폭)
        // 최소값: H/2 (원치수/2)
        // 최대값: 1.5 × ho
        // 기본값: 최소값
        function updateOpeningWidth() {
            const beamDepthEl = document.getElementById('beamDepth');
            const openingHeightEl = document.getElementById('openingHeight');
            const openingWidthEl = document.getElementById('openingWidth');
            const openingWidthMinEl = document.getElementById('openingWidthMin');
            const openingWidthMaxEl = document.getElementById('openingWidthMax');
            
            if (!beamDepthEl || !openingHeightEl || !openingWidthEl) {
                return;
            }
            
            const dc = parseFloat(beamDepthEl.value) || 0;  // mm 단위
            const ho = parseFloat(openingHeightEl.value) || 0;  // m 단위
            
            if (dc > 0 && ho > 0) {
                // 원치수 = dc / 1.5
                const originalHeight = dc / 1.5;  // mm
                
                // 최소값: H/2 (원치수/2)
                const eMin = Math.round(originalHeight / 2);  // mm
                
                // 최대값: 1.5 × ho (ho는 m 단위이므로 mm로 변환)
                const hoMm = ho * 1000;  // m → mm
                const eMax = Math.round(1.5 * hoMm);  // mm
                
                // 범위 표시
                if (openingWidthMinEl) {
                    openingWidthMinEl.textContent = eMin;
                }
                if (openingWidthMaxEl) {
                    openingWidthMaxEl.textContent = eMax;
                }
                
                // 입력 필드의 min, max 속성 설정
                openingWidthEl.min = eMin;
                openingWidthEl.max = eMax;
                
                // 현재 값이 범위를 벗어나면 최소값으로 설정
                const currentValue = parseFloat(openingWidthEl.value) || 0;
                if (currentValue < eMin || currentValue > eMax || currentValue === 0) {
                    openingWidthEl.value = eMin;
                }
            }
        }

        // Initialize on page load
        initializeType();
        
        // 초기 개구부 높이, 간격, End Post 및 개구부 폭, 보 자중, 슬래브 자중 계산
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                updateOpeningHeight();
                updateEndPost();
                updateSelfWeight();
                updateSlabWeight();
                // openingWidth가 업데이트된 후 openingSpacing 업데이트
                setTimeout(function() {
                    updateOpeningWidth();
                    setTimeout(updateOpeningSpacing, 10);
                }, 10);
            });
        } else {
            updateOpeningHeight();
            updateEndPost();
            updateSelfWeight();
            updateSlabWeight();
            // openingWidth가 업데이트된 후 openingSpacing 업데이트
            setTimeout(function() {
                updateOpeningWidth();
                setTimeout(updateOpeningSpacing, 10);
            }, 10);
        }
        
        // beamDepth 변경 시 개구부 높이, 간격, End Post 및 개구부 폭 자동 업데이트
        const beamDepthEl = document.getElementById('beamDepth');
        if (beamDepthEl) {
            beamDepthEl.addEventListener('input', function() {
                updateOpeningHeight();
                updateEndPost();
                // openingHeight가 업데이트된 후 openingWidth 업데이트
                setTimeout(function() {
                    updateOpeningWidth();
                    // openingWidth가 업데이트된 후 openingSpacing 업데이트
                    setTimeout(updateOpeningSpacing, 10);
                }, 10);
            });
            beamDepthEl.addEventListener('change', function() {
                updateOpeningHeight();
                updateEndPost();
                // openingHeight가 업데이트된 후 openingWidth 업데이트
                setTimeout(function() {
                    updateOpeningWidth();
                    // openingWidth가 업데이트된 후 openingSpacing 업데이트
                    setTimeout(updateOpeningSpacing, 10);
                }, 10);
            });
        }
        
        // openingHeight 변경 시 웹 포스트 폭(e) 범위 업데이트
        const openingHeightEl = document.getElementById('openingHeight');
        if (openingHeightEl) {
            openingHeightEl.addEventListener('input', updateOpeningWidth);
            openingHeightEl.addEventListener('change', updateOpeningWidth);
        }
        
        // openingWidth 변경 시 개구부 간격 자동 업데이트
        const openingWidthEl = document.getElementById('openingWidth');
        if (openingWidthEl) {
            openingWidthEl.addEventListener('input', updateOpeningSpacing);
            openingWidthEl.addEventListener('change', updateOpeningSpacing);
        }

        // 보 자중 자동 계산 함수
        // KS 섹션 선택 시: 해당 섹션의 단중(kg/m)을 하중폭으로 나눈 값 사용
        // 직접 입력 시: 단면 치수로부터 계산
        function updateSelfWeight() {
            try {
                const ksSectionSelect = document.getElementById('ksSection');
                const selectedKsSection = ksSectionSelect?.value || '';
                const B = parseFloat(document.getElementById('loadWidth')?.value) || 0;  // m
                const selfWeightElement = document.getElementById('selfWeight');

                if (!selfWeightElement || B <= 0) {
                    if (selfWeightElement && B <= 0) {
                        selfWeightElement.value = '';
                    }
                    return;
                }

                let selfWeight_kNm2 = 0;

                // KS 섹션이 선택된 경우: 해당 섹션의 단중 사용
                if (selectedKsSection && selectedKsSection !== '' && ksSections[selectedKsSection]) {
                    const section = ksSections[selectedKsSection];
                    if (section.unitWeight) {
                        // 단중(kg/m)을 kN/m로 변환: kg/m × 9.81 / 1000 = kg/m × 0.00981
                        const selfWeight_kNm = section.unitWeight * 0.00981; // kN/m
                        // 하중폭(B)으로 나눈 값 (kN/m²)
                        selfWeight_kNm2 = selfWeight_kNm / B; // kN/m²
                    }
                } else {
                    // 직접 입력 모드: 단면 치수로부터 계산
                    const d = parseFloat(document.getElementById('beamDepth')?.value) || 0;  // mm
                    const bf = parseFloat(document.getElementById('flangeWidth')?.value) || 0;  // mm
                    const tf = parseFloat(document.getElementById('flangeThickness')?.value) || 0;  // mm
                    const tw = parseFloat(document.getElementById('webThickness')?.value) || 0;  // mm

                    if (d <= 0 || bf <= 0 || tf <= 0 || tw <= 0) {
                        selfWeightElement.value = '';
                        return;
                    }

                    const hw = d - 2 * tf;
                    const area = bf * tf * 2 + hw * tw; // mm²
                    const gamma = 78.5; // kN/m³ (강재 단위중량)
                    const selfWeight_kNm = (area / 1000000) * gamma; // kN/m (철골보 자중)
                    
                    // 하중폭(B)으로 나눈 값 (kN/m²)
                    selfWeight_kNm2 = selfWeight_kNm / B; // kN/m²
                }

                // 보 자중을 하중폭으로 나눈 값 표시
                if (selfWeight_kNm2 > 0) {
                    selfWeightElement.value = selfWeight_kNm2.toFixed(3);
                } else {
                    selfWeightElement.value = '';
                }
            } catch (e) {
                console.error('[ERROR] updateSelfWeight exception:', e);
            }
        }

        // 슬래브 자중 자동계산 함수
        function updateSlabWeight() {
            try {
                const slabThicknessElement = document.getElementById('slabThickness');
                const slabWeightElement = document.getElementById('slabWeight');
                
                if (!slabThicknessElement || !slabWeightElement) {
                    return;
                }

                const ts = parseFloat(slabThicknessElement.value) || 0;
                
                // 콘크리트 단위중량: 24 kN/m³
                const gamma_concrete = 24; // kN/m³
                
                // 슬래브 자중 = (ts / 1000) * gamma_concrete (kN/m²)
                // ts는 mm 단위이므로 m로 변환 (ts / 1000)
                const slabWeight_kNm2 = (ts / 1000) * gamma_concrete;
                
                if (slabWeight_kNm2 > 0) {
                    slabWeightElement.value = slabWeight_kNm2.toFixed(3);
                } else {
                    slabWeightElement.value = '';
                }
            } catch (e) {
                console.error('[ERROR] updateSlabWeight exception:', e);
            }
        }

        // 보 자중 자동 계산을 위한 이벤트 리스너
        ['beamDepth', 'flangeWidth', 'flangeThickness', 'webThickness', 'loadWidth', 'ksSection'].forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                element.addEventListener('input', updateSelfWeight);
                element.addEventListener('change', updateSelfWeight);
            }
        });

        // 슬래브 자중 자동 계산을 위한 이벤트 리스너
        const slabThicknessElement = document.getElementById('slabThickness');
        if (slabThicknessElement) {
            slabThicknessElement.addEventListener('input', updateSlabWeight);
            slabThicknessElement.addEventListener('change', updateSlabWeight);
        }
        
        // Initialize KS section options
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                populateKsSectionOptions();
                const ksSectionSelect = document.getElementById('ksSection');
                if (ksSectionSelect) {
                    ksSectionSelect.addEventListener('change', onKsSectionChange);
                }
            });
        } else {
            populateKsSectionOptions();
            const ksSectionSelect = document.getElementById('ksSection');
            if (ksSectionSelect) {
                ksSectionSelect.addEventListener('change', onKsSectionChange);
            }
        }
    </script>
</body>
</html>
